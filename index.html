<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Raven’s DOX2 Trait Engine</title>
<style>
:root {
  --bg-color: #f0f0f0;
  --section-bg: #fff;
  --result-bg: #cfe0ff;
  --sticky-bg: #e0e0ff;
  --text-color: #000;
}
body { font-family: Arial, sans-serif; padding:20px; background: var(--bg-color); color: var(--text-color); margin:0;}
h1 {text-align:center; font-size:36px; margin-bottom:10px;}
h2 { font-size:28px; margin-top:0;}
.section { background: var(--section-bg); padding:20px; margin-bottom:20px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.1);}
label { display:block; margin-top:10px; font-size:20px; }
select, input[type=number], input[type=text] { margin:10px 0; padding:10px; width:100%; font-size:20px;}
.sticky-header { position: sticky; top:0; background: var(--sticky-bg); padding:15px 20px; z-index:999; border-bottom:2px solid #999; box-shadow:0 4px 6px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 10px;}
.header-top { display: flex; align-items: center; gap: 10px; }
.header-top h2 { margin: 0; font-size: 35px; }
.header-top .result { flex-grow: 1; margin: 0; font-size: 30px; padding: 15px; }
.header-bottom { display: flex; justify-content: center; gap: 10px; }
.header-bottom .clear-buttons { display: flex; gap: 5px; }
.header-bottom .clear-buttons button, .header-bottom button#toggleView { font-size: 20px; padding: 10px 20px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; white-space: nowrap; }
body.dark-mode .header-bottom .clear-buttons button, body.dark-mode .header-bottom button#toggleView { background-color: #495057; }
.result { background: var(--result-bg); padding:15px; border-radius:5px; margin-top:10px; font-weight:bold; font-size:30px;}
.warning { color:red; font-weight:bold; }
.flex-row { display:flex; gap:5px; flex-wrap:wrap; }
.flex-row label { flex:1; }
.flex-row select, .flex-row input[type=number] { flex:1; }
@media(max-width:600px){h1{font-size:28px;}h2{font-size:22px;} select,input[type=number],input[type=text]{font-size:18px;}}
body.dark-mode {--bg-color:#1c1c1c;--section-bg:#2c2c2c;--result-bg:#3a3a5c;--sticky-bg:#3a3a5c;--text-color:#f0f0f0;}
#toggleTheme {font-size:20px; padding:14px 28px; border-radius:12px; cursor:pointer; background-color:#4a90e2; color:#fff; border:none; margin-bottom:20px;}

/* Collapsible Calculator */
.calc-widget { position: fixed; bottom: 60px; right: 10px; width: 220px; background: var(--section-bg); box-shadow:0 4px 10px rgba(0,0,0,0.2); border-radius:10px; padding:10px; z-index:2000; display:none;}
.calc-display { width:100%; height:40px; font-size:20px; margin-bottom:8px; text-align:right; padding:5px;}
.calc-buttons { display:grid; grid-template-columns: repeat(4,1fr); gap:5px;}
.calc-buttons button { padding:12px; font-size:18px; border-radius:6px; border:none; cursor:pointer;}
#toggleCalc {position: fixed; bottom: 10px; right: 10px; z-index:3000; background:#4a90e2; color:#fff; border:none; border-radius:10px; padding:10px 15px; font-size:16px; cursor:pointer;}
@media(max-width:900px){.calc-widget{width:180px; right:10px; bottom:80px;}}

/* Exclusions */
.exclusions { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }
.exclusions label { font-size: 18px; }
.exclusions select { height: 120px; font-size: 16px; }

/* Optimize buttons */
.optimize-buttons { display: flex; justify-content: center; gap: 10px; flex-wrap: nowrap; margin-top: 20px; flex-wrap: wrap; }
.optimize-buttons button { font-size: 30px; padding: 19px 38px; }
.optimize-buttons button#optDamageLegendary { background-color: #dc3545; color: white; } /* Red to highlight special */
@media (max-width: 1200px) {
  .optimize-buttons button { font-size: 24px; padding: 15px 30px; }
}

/* Combined sections */
.combined-section { display: flex; gap: 20px; flex-wrap: wrap; }
.combined-section > div { flex: 1; min-width: 200px; }
.combined-section select { width: 100%; padding: 5px; font-size: 16px; }
.combined-section label { font-size: 16px; margin-top:5px; }
.combined-section input[type=number] { width: 100%; padding: 5px; font-size: 16px; }
.combined-section h4 { font-size: 20px; margin-bottom: 10px; }
.combined-section .addable-column { flex: 1; min-width: 200px; }

/* Build Management */
.build-management { display: flex; flex-direction: column; gap: 15px; }
.build-management .top-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
.build-management .top-row input { flex: 2; min-width: 200px; }
.build-management .top-row button { flex: 1; min-width: 120px; }
.build-management select { width: 100%; }
.build-management .bottom-row { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
.build-management .bottom-row button { flex: 1; min-width: 120px; font-size: 18px; padding: 12px; }

/* Pygmy Starting % Alignment */
.pygmy-totals { display: flex; flex-direction: column; gap: 10px; align-items: flex-end; max-width: 40%; margin-left: auto; }
.pygmy-totals label { display: flex; align-items: center; justify-content: flex-end; gap: 10px; width: 100%; }
.pygmy-totals input { width: 100px; text-align: right; }
@media (max-width: 768px) {
  .pygmy-totals { max-width: 100%; align-items: stretch; }
  .pygmy-totals label { justify-content: space-between; }
}
</style>
</head>
<body class="dark-mode">

<h1>Raven’s DOX2 Trait Engine</h1>
<div style="text-align:center;"><button id="toggleTheme">Switch to Light Mode</button></div>

<div class="section sticky-header">
<div class="header-top">
<h2>Trait Power %</h2>
<div class="result" id="finalResult">Damage: 1.0, DR: 1.0, SPD: 1.0</div>
</div>
<div class="header-bottom">
<button id="toggleView">Swap Trait Power View</button>
<div class="clear-buttons">
<button id="clearOptimized">Clear Optimized</button>
<button id="clearAll">Clear All</button>
</div>
</div>
</div>

<div class="section">
<h2>Optimize Build</h2>
<div class="optimize-buttons">
<button id="optDamage" title="optimizations will prioritize 75% DR, then optimize for chosen attributes while respecting the minimum desired movement speed if entered">Optimize for Damage</button>
<button id="optSpeed" title="optimizations will prioritize 75% DR, then optimize for chosen attributes while respecting the minimum desired movement speed if entered">Optimize for Speed</button>
<button id="optAll" title="optimizations will prioritize 75% DR, then optimize for chosen attributes while respecting the minimum desired movement speed if entered">Optimize for Least Waste</button>
<button id="optDamageLegendary" title="optimizations will prioritize 75% DR, then optimize for chosen attributes while respecting the minimum desired movement speed if entered">Optimize for Damage w/ Selected Legendary</button>
</div>
<label>Minimum Desired Speed %: <input type="number" id="minSpeed" placeholder="e.g., 20" step="0.1" style="width: 33%; padding: 5px; font-size: 16px;"><span id="speed-context"></span></label>
<h2>Exclusions</h2>
<p>Use exclusions if you are missing some traits and don’t want them to be considered</p>
<div class="exclusions">
<label>Exclude W: <select id="excludeW" multiple></select></label>
<label>Exclude N: <select id="excludeN" multiple></select></label>
<label>Exclude A: <select id="excludeA" multiple></select></label>
<label>Exclude UW: <select id="excludeUW" multiple></select></label>
<label>Exclude U: <select id="excludeU" multiple></select></label>
<label>Exclude Legendary: <select id="excludeL" multiple></select></label>
<label>Exclude Prime: <select id="excludeP" multiple></select></label>
<label>Exclude Mega: <select id="excludeM" multiple></select></label>
</div>
</div>

<div class="section combined-section">
<div>
<h2>Corrupt and Greaters</h2>
<div class="flex-row">
<label>Corrupt String Stat:
<select id="corruptStat"></select></label>
<label>Bonus (%): <input type="number" id="corruptInput" min="-25" max="25" placeholder="Enter -25 to 25%"></label>
</div>
<div class="flex-row">
<label>Greater String 1 Stat:
<select id="geneticStat0"></select></label>
<label>Bonus (%): <input type="number" id="geneticValue0" min="5" max="10" placeholder="Enter 5-10%"></label>
</div>
<div class="flex-row">
<label>Greater String 2 Stat:
<select id="geneticStat1"></select></label>
<label>Bonus (%): <input type="number" id="geneticValue1" min="5" max="10" placeholder="Enter 5-10%"></label>
</div>
<div class="flex-row">
<label>Greater String 3 Stat:
<select id="geneticStat2"></select></label>
<label>Bonus (%): <input type="number" id="geneticValue2" min="5" max="10" placeholder="Enter 5-10%"></label>
</div>
</div>
<div>
<h2>Cleanse Counters</h2>
<div class="flex-row">
<label>Trait Cleanse Counter:
<input type="number" id="traitCleanseCounter" min="1" max="5" placeholder="Enter 1-5"></label>
</div>
<div class="flex-row">
<label>Absolute Trait Cleanse Counter:
<input type="number" id="absoluteTraitCleanseCounter" min="1" max="3" placeholder="Enter 1-3"></label>
</div>
</div>
</div>

<div class="section combined-section">
<div>
<h2>Prime & Mega Traits</h2>
<label>Prime Trait:<select id="Prime"></select></label>
<label>Mega Trait:<select id="Mega"></select></label>
</div>
<div>
<h2 title="Be sure to add all 3 N traits before any A traits as they occupy the same slots">Artificial Traits (A) – Max 3</h2>
<select id="A1"></select>
<select id="A2"></select>
<select id="A3"></select>
</div>
</div>

<div class="section combined-section">
<div>
<h2 title="Be sure to add all 3 N traits before any A traits as they occupy the same slots">Wild Traits (W) – Max 3</h2>
<select id="W1"></select>
<select id="W2"></select>
<select id="W3"></select>
</div>
<div>
<h2 title="Be sure to add all 3 N traits before any A traits as they occupy the same slots">Natural Traits (N) – Max 3</h2>
<select id="N1"></select>
<select id="N2"></select>
<select id="N3"></select>
</div>
</div>

<div class="section combined-section">
<div>
<h2>Unique Wild (UW)</h2>
<select id="UW"></select>
</div>
<div>
<h2>Unique (U)</h2>
<select id="U"></select>
</div>
</div>

<div class="section">
<h2>Legendary Trait (Optional)</h2>
<select id="Legendary"></select>
<p class="warning">Make sure to feed the legendary trait early in the order so that you can fix the negative modifiers with subsequent added traits. Legendaries are not automatically used in optimization unless selected here.</p>
</div>

<div class="section">
<h2>Calculate Final HP</h2>
<input type="number" id="targetHP" placeholder="Enter Desired Final HP after Prime and Mega traits added" style="width: 33%; padding: 5px; font-size: 16px;">
</div>

<div class="section">
<h2>Build Management</h2>
<div class="build-management">
  <div class="top-row">
    <input type="text" id="buildName" placeholder="Build Name" style="padding: 10px; font-size: 18px;">
    <button id="saveBuild" style="font-size: 18px; padding: 10px 20px;">Save Build</button>
  </div>
  <select id="savedBuilds" style="padding: 10px; font-size: 18px;"></select>
  <div class="bottom-row">
    <button id="loadBuild" style="font-size: 18px; padding: 12px 20px;">Load Build</button>
    <button id="deleteBuild" style="font-size: 18px; padding: 12px 20px;">Delete Build</button>
    <button id="shareBuild" style="font-size: 18px; padding: 12px 20px;">Share Build</button>
  </div>
</div>
</div>

<div class="section" id="pygmyTraitPlanner">
<h2>Pygmy Trait Engine</h2>
<p>Feed the corrupt and greater strings to your pygmy if desired, then enter your Pygmy's starting traits (for slot tracking) and current total % bonuses below. The planner will suggest optimal additions.</p>

<h3>Starting Traits</h3>
<div class="combined-section">
<div>
<h4 title="Be sure to add all 3 N traits before any A traits as they occupy the same slots">Starting Wild Traits (W) – Up to 3</h4>
<select id="pygmyStartingW1"></select>
<select id="pygmyStartingW2"></select>
<select id="pygmyStartingW3"></select>
</div>
<div>
<h4 title="Be sure to add all 3 N traits before any A traits as they occupy the same slots">Starting Natural Traits (N) – Up to 3</h4>
<select id="pygmyStartingN1"></select>
<select id="pygmyStartingN2"></select>
<select id="pygmyStartingN3"></select>
</div>
</div>

<div class="combined-section">
<div>
<h4>Starting Unique Wild (UW)</h4>
<select id="pygmyStartingUW"></select>
</div>
<div>
<h4>Starting Prime (P)</h4>
<select id="pygmyStartingPrime"></select>
<h4>Starting Mega (M)</h4>
<select id="pygmyStartingMega"></select>
</div>
</div>

<h3>Current Totals (from fed strings & starting traits)</h3>
<div class="pygmy-totals">
<label>Current Damage %: <input type="number" id="pygmyStartingDmg" placeholder="DMG %" style="width: 100px;"></label>
<label>Current DR %: <input type="number" id="pygmyStartingDR" placeholder="DR %" style="width: 100px;"></label>
<label>Current Speed %: <input type="number" id="pygmyStartingSpd" placeholder="SPD %" style="width: 100px;"></label>
</div>

<!-- Addable Traits -->
<h3>Addable Traits</h3>
<p>If your Pygmy already has a P or M trait, it is not possible to add any new P or M traits.</p>
<div class="combined-section" id="pygmyAddableTraits">
<!-- Dynamically populated via JS -->
</div>
<label>Minimum Desired Speed %: <input type="number" id="pygmyMinSpeed" placeholder="e.g., 20" step="0.1" style="width: 33%; padding: 5px; font-size: 16px;"><span id="pygmySpeedContext"></span></label>

<div class="optimize-buttons">
<button id="pygmyOptDamage" title="optimizations will prioritize 75% DR, then optimize for chosen attributes while respecting the minimum desired movement speed if entered">Optimize for Damage</button>
<button id="pygmyOptSpeed" title="optimizations will prioritize 75% DR, then optimize for chosen attributes while respecting the minimum desired movement speed if entered">Optimize for Speed</button>
<button id="pygmyOptAll" title="optimizations will prioritize 75% DR, then optimize for chosen attributes while respecting the minimum desired movement speed if entered">Optimize for Least Waste</button>
</div>

<!-- Exclusions for Additions -->
<h3>Exclusions for Additions</h3>
<div class="exclusions">
<label>Exclude W: <select id="pygmyExcludeW" multiple></select></label>
<label>Exclude N: <select id="pygmyExcludeN" multiple></select></label>
<label>Exclude A: <select id="pygmyExcludeA" multiple></select></label>
<label>Exclude UW: <select id="pygmyExcludeUW" multiple></select></label>
<label>Exclude U: <select id="pygmyExcludeU" multiple></select></label>
<label>Exclude Prime: <select id="pygmyExcludeP" multiple></select></label>
<label>Exclude Mega: <select id="pygmyExcludeM" multiple></select></label>
</div>

<div class="result" id="pygmyFinalResult">Pygmy Bonus: Damage: 1.0, DR: 1.0, SPD: 1.0</div>
</div>

<!-- Collapsible Calculator -->
<button id="toggleCalc">Show Calculator</button>
<div class="calc-widget" id="calcWidget">
<input type="text" class="calc-display" id="calcDisplay" readonly>
<div class="calc-buttons">
<button onclick="calcPress('7')">7</button><button onclick="calcPress('8')">8</button><button onclick="calcPress('9')">9</button><button onclick="calcPress('/')">÷</button>
<button onclick="calcPress('4')">4</button><button onclick="calcPress('5')">5</button><button onclick="calcPress('6')">6</button><button onclick="calcPress('*')">×</button>
<button onclick="calcPress('1')">1</button><button onclick="calcPress('2')">2</button><button onclick="calcPress('3')">3</button><button onclick="calcPress('-')">−</button>
<button onclick="calcPress('0')">0</button><button onclick="calcPress('.')">.</button><button onclick="calcClear()">C</button><button onclick="calcPress('+')">+</button>
<button style="grid-column: span 4; background:#4a90e2; color:white;" onclick="calcEquals()">=</button>
</div>
</div>

<!-- Debug Log Section -->
<div class="section">
<h2>Debug Log</h2>
<textarea id="debugLog" readonly style="width:100%; height:200px; font-size:14px;"></textarea>
<div style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
<button id="refreshLog">Refresh Log</button>
<button id="copyLog">Copy Log to Clipboard</button>
<button id="clearLog">Clear Log</button>
</div>
</div>

<script>
// Debug Log Setup
let debugLogs = [];
function logDebug(message) {
  const timestamp = new Date().toLocaleString();
  debugLogs.push(`[${timestamp}] ${message}`);
}
window.onerror = function(message, source, lineno, colno, error) {
  logDebug(`Error: ${message} at line ${lineno}:${colno}`);
  return false;
};

// ---------------------------
// TRAIT DATABASE
// ---------------------------
const traitData={
"W":[{N:"Tough",D:10,DR:10,S:-5},{N:"Balanced",D:7.5,DR:5,S:5},{N:"Runner",D:-5,DR:0,S:15},{N:"Brawler",D:15,DR:2.5,S:-5}],
"N":[{N:"Tough",D:0,DR:15,S:-5},{N:"Balanced",D:5,DR:0,S:5},{N:"Runner",D:-5,DR:0,S:10},{N:"Brawler",D:10,DR:5,S:-5}],
"A":[{N:"Tough",D:0,DR:5,S:-2.5},{N:"Balanced",D:2.5,DR:0,S:2.5},{N:"Runner",D:0,DR:0,S:5},{N:"Brawler",D:5,DR:2.5,S:-2.5}],
"UW":[{N:"Tough",D:15,DR:7.5,S:-5},{N:"Balanced",D:10,DR:5,S:5},{N:"Runner",D:-5,DR:0,S:15},{N:"Juggernaut",D:12.5,DR:10,S:-2.5}],
"U":[{N:"Tough",D:5,DR:15,S:-2.5},{N:"Balanced",D:10,DR:0,S:10},{N:"Runner",D:-5,DR:0,S:15},{N:"Juggernaut",D:15,DR:10,S:-5}],
"P":[{N:"Tough",D:15,DR:20,S:0},{N:"Balanced",D:20,DR:0,S:5},{N:"Runner",D:0,DR:0,S:25},{N:"Juggernaut",D:25,DR:15,S:-5}],
"M":[{N:"Tough",D:15,DR:25,S:0},{N:"Balanced",D:25,DR:0,S:7.5},{N:"Runner",D:0,DR:0,S:15},{N:"Juggernaut",D:30,DR:20,S:-5}],
"L":[{N:"Alpha",D:50,DR:-12.5,S:-12.5},{N:"Gamma",D:20,DR:20,S:-25},{N:"Omega",D:25,DR:-20,S:25}]
};

// ---------------------------
// POPULATE DROPDOWNS
// ---------------------------
function populateDropdowns(){
  logDebug("Populating dropdowns");
  const mapping={W:["W1","W2","W3"],N:["N1","N2","N3"],A:["A1","A2","A3"],UW:["UW"],U:["U"],P:["Prime"],M:["Mega"],L:["Legendary"]};
  for(const cat in mapping){
    mapping[cat].forEach(id=>{
      const select=document.getElementById(id);
      if (!select) return;
      select.innerHTML="";
      const empty=document.createElement("option");
      empty.value=""; empty.textContent="--Select--"; select.appendChild(empty);
      traitData[cat].forEach((t,i)=>{
        const opt=document.createElement("option");
        opt.value=`${cat}-${i}`;
        let parts=[];
        if(t.D!==0) parts.push(`DMG ${t.D>0?"+":""}${t.D}`);
        if(t.DR!==0) parts.push(`DR ${t.DR>0?"+":""}${t.DR}`);
        if(t.S!==0) parts.push(`SPD ${t.S>0?"+":""}${t.S}`);
        opt.text=`${t.N}${parts.length>0?` (${parts.join(", ")})`:""}`;
        select.appendChild(opt);
      });
    });
  }

  for(let i=0;i<3;i++){
    const select=document.getElementById("geneticStat"+i);
    select.innerHTML="";
    const empty=document.createElement("option"); empty.value=""; empty.textContent="--Select Stat--"; select.appendChild(empty);
    ["Damage","DR","Speed"].forEach(stat=>{
      const opt=document.createElement("option"); opt.value=stat; opt.textContent=stat; select.appendChild(opt);
    });
  }

  const corruptSelect = document.getElementById("corruptStat");
  corruptSelect.innerHTML="";
  const corruptEmpty = document.createElement("option"); corruptEmpty.value=""; corruptEmpty.textContent="--Select Stat--"; corruptSelect.appendChild(corruptEmpty);
  ["Damage","DR","Speed"].forEach(stat=>{
    const opt=document.createElement("option"); opt.value=stat; opt.textContent=stat; corruptSelect.appendChild(opt);
  });

  // Populate exclude selects
  for(const cat in traitData){
    const excludeSelect = document.getElementById(`exclude${cat}`);
    if(excludeSelect) {
      excludeSelect.innerHTML = "";
      traitData[cat].forEach((t, i) => {
        const opt=document.createElement("option");
        opt.value = i;
        opt.textContent = t.N;
        excludeSelect.appendChild(opt);
      });
    }
  }
}

// ---------------------------
// GET CURRENT TOTALS
// ---------------------------
function getCurrentTotals() {
  logDebug("Calculating current totals");
  let total = {Damage: 0, DR: 0, Speed: 0};
  ["W1","W2","W3","N1","N2","N3","A1","A2","A3","UW","U","Prime","Mega","Legendary"].forEach(id => {
    const val = document.getElementById(id)?.value;
    if (val && val.includes("-")) {
      const [cat, i] = val.split("-");
      const t = traitData[cat][parseInt(i)];
      total.Damage += t.D || 0;
      total.DR += t.DR || 0;
      total.Speed += t.S || 0;
    }
  });
  const corrupt = document.getElementById("corruptStat").value;
  if (corrupt) total[corrupt] += parseFloat(document.getElementById("corruptInput").value) || 0;
  for (let i = 0; i < 3; i++) {
    const stat = document.getElementById("geneticStat" + i).value;
    const val = parseFloat(document.getElementById("geneticValue" + i).value) || 0;
    if (stat) total[stat] += val;
  }
  return total;
}

// ---------------------------
// CALCULATE FINAL STATS
// ---------------------------
let isMultiplierView = true;
function calculateFinalStats(){
  logDebug("Calculating final stats");
  const total = getCurrentTotals();
  let drPercent=total.DR;
  let drWarning="";
  if(drPercent>75){ drWarning=` <span class="warning">(${(drPercent-75).toFixed(1)}% over cap)</span>`; drPercent=Math.min(drPercent,75);}
  const dmg=1+total.Damage/100, dr=1-drPercent/100, spd=1+total.Speed/100;
  let out;
  if(isMultiplierView){
    out=`Damage: ${dmg.toFixed(3)}, DR: ${dr.toFixed(3)}${drWarning}, SPD: ${spd.toFixed(3)}`;
  }else{
    out=`Damage: ${total.Damage.toFixed(1)}%, DR: ${drPercent.toFixed(1)}%${drWarning}, SPD: ${total.Speed.toFixed(1)}%`;
  }
  const target=parseFloat(document.getElementById("targetHP").value);
  if(target){const prime=1.25, mega=1.40; out+=`<br><b>Level HP to ~</b>${Math.round(target/(prime*mega))} before Prime & Mega`;}
  document.getElementById("finalResult").innerHTML=out;
}

// ---------------------------
// SIMPLE CALCULATOR
// ---------------------------
const calcDisplay=document.getElementById("calcDisplay");
function calcPress(v){calcDisplay.value+=v;}
function calcClear(){calcDisplay.value="";}
function calcEquals(){try{calcDisplay.value=eval(calcDisplay.value);}catch{calcDisplay.value="Error";}}
document.getElementById("toggleCalc").onclick=()=>{
  const w=document.getElementById("calcWidget");
  const btn=document.getElementById("toggleCalc");
  if(w.style.display==="block"){w.style.display="none"; btn.textContent="Show Calculator";}
  else{w.style.display="block"; btn.textContent="Hide Calculator";}
};

// ---------------------------
// SAVE/LOAD BUILDS
// ---------------------------
let savedBuilds = JSON.parse(localStorage.getItem("savedBuilds")) || {};
function saveBuild(){
  logDebug("Saving build");
  const name=document.getElementById("buildName").value.trim();
  if(!name)return alert("Enter build name!");
  savedBuilds[name]={};
  ["W1","W2","W3","N1","N2","N3","A1","A2","A3","UW","U","Prime","Mega","Legendary","corruptStat","corruptInput","geneticStat0","geneticStat1","geneticStat2","geneticValue0","geneticValue1","geneticValue2","targetHP","traitCleanseCounter","absoluteTraitCleanseCounter"].forEach(id=>{
    savedBuilds[name][id]=document.getElementById(id)?.value || "";
  });
  localStorage.setItem("savedBuilds", JSON.stringify(savedBuilds));
  updateSavedDropdown();
}
function updateSavedDropdown(){
  const sel=document.getElementById("savedBuilds"); sel.innerHTML="";
  Object.keys(savedBuilds).forEach(name=>{
    const opt=document.createElement("option"); opt.value=name; opt.textContent=name; sel.appendChild(opt);
  });
}
function loadBuild(){
  logDebug("Loading build");
  const name=document.getElementById("savedBuilds").value; if(!name)return;
  const data=savedBuilds[name];
  Object.keys(data).forEach(id=>{if(document.getElementById(id)) document.getElementById(id).value=data[id];});
  calculateFinalStats();
}
function deleteBuild(){
  logDebug("Deleting build");
  const name=document.getElementById("savedBuilds").value; if(!name)return;
  delete savedBuilds[name];
  localStorage.setItem("savedBuilds", JSON.stringify(savedBuilds));
  updateSavedDropdown();
}

// ---------------------------
// SHARE BUILD
// ---------------------------
document.getElementById("shareBuild").onclick = function() {
  logDebug("Sharing build");
  let buildData = {};
  ["W1","W2","W3","N1","N2","N3","A1","A2","A3","UW","U","Prime","Mega","Legendary","corruptStat","corruptInput","geneticStat0","geneticStat1","geneticStat2","geneticValue0","geneticValue1","geneticValue2","targetHP","traitCleanseCounter","absoluteTraitCleanseCounter"].forEach(id => {
    buildData[id] = document.getElementById(id)?.value || "";
  });
  
  const encoded = btoa(JSON.stringify(buildData));
  const shareUrl = `${window.location.origin}${window.location.pathname}?build=${encoded}`;
  
  navigator.clipboard.writeText(shareUrl).then(() => {
    alert("Shareable URL copied to clipboard! Paste it to someone else.");
  }).catch(() => {
    prompt("Copy this shareable URL:", shareUrl);
  });
};

// ---------------------------
// LOAD SHARED BUILD FROM URL
// ---------------------------
function loadFromUrl() {
  logDebug("Loading from URL");
  const urlParams = new URLSearchParams(window.location.search);
  const buildParam = urlParams.get('build');
  if (buildParam) {
    try {
      const data = JSON.parse(atob(buildParam));
      Object.keys(data).forEach(id => {
        if (document.getElementById(id)) {
          document.getElementById(id).value = data[id];
        }
      });
      calculateFinalStats();
      alert("Build loaded from shared URL!");
    } catch (e) {
      logDebug("Error loading shared build: " + e.message);
      console.error("Invalid shared build data:", e);
    }
  }
}

// ---------------------------
// OPTIMIZE FUNCTIONS
// ---------------------------
const groups = [
  {cat: 'W', num_slots: 3, ids: ['W1', 'W2', 'W3']},
  {cat: 'N', num_slots: 3, ids: ['N1', 'N2', 'N3']},
  {cat: 'A', num_slots: 3, ids: ['A1', 'A2', 'A3']},
  {cat: 'UW', num_slots: 1, ids: ['UW']},
  {cat: 'U', num_slots: 1, ids: ['U']},
  {cat: 'L', num_slots: 1, ids: ['Legendary']},
  {cat: 'P', num_slots: 1, ids: ['Prime']},
  {cat: 'M', num_slots: 1, ids: ['Mega']}
];

function getOptions(cat, count, excluded) {
  if (count === 0) return [{d:0, dr:0, s:0, combo:[]}];
  logDebug(`Getting options for ${cat} count ${count}, excluded: ${excluded}`);
  const traits = traitData[cat].filter((t, i) => !excluded.includes(i));
  const len = traits.length;
  const opts = [];
  const generateCombo = (remaining, current = [], start = 0) => {
    if (remaining === 0) {
      let d = 0, dr = 0, s = 0;
      const origCombo = current.map(filteredI => traitData[cat].findIndex(origT => origT.N === traits[filteredI].N)).sort((a, b) => a - b);
      current.forEach(filteredI => {
        const t = traits[filteredI];
        d += t.D || 0;
        dr += t.DR || 0;
        s += t.S || 0;
      });
      opts.push({ d, dr, s, combo: origCombo });
      return;
    }
    for (let i = start; i < len; i++) {
      generateCombo(remaining - 1, [...current, i], i);
    }
  };
  generateCombo(count);
  logDebug(`Generated ${opts.length} options for ${cat} count ${count}`);
  return opts;
}

function clearOptimizedTraits() {
  logDebug("Clearing optimized traits");
  groups.forEach(g => {
    if (g.cat !== 'P' && g.cat !== 'M') {
      g.ids.forEach(id => document.getElementById(id).value = "");
    }
  });
  calculateFinalStats();
}

function clearAll() {
  logDebug("Clearing all");
  groups.forEach(g => g.ids.forEach(id => document.getElementById(id).value = ""));
  document.getElementById("corruptStat").value = "";
  document.getElementById("corruptInput").value = "";
  for (let i = 0; i < 3; i++) {
    document.getElementById("geneticStat" + i).value = "";
    document.getElementById("geneticValue" + i).value = "";
  }
  document.getElementById("targetHP").value = "";
  document.getElementById("minSpeed").value = "";
  document.getElementById("traitCleanseCounter").value = "";
  document.getElementById("absoluteTraitCleanseCounter").value = "";
  for (const cat in traitData) {
    const excludeSelect = document.getElementById(`exclude${cat}`);
    if (excludeSelect) {
      for (let opt of excludeSelect.options) opt.selected = false;
    }
  }
  calculateFinalStats();
}

function optimize(mode) {
  logDebug(`Starting optimization for mode: ${mode}`);
  document.getElementById('speed-context').innerHTML = '';
  const minDR = 75;
  const userMinS = parseFloat(document.getElementById('minSpeed').value) || 0;
  const wd = (mode === 'damage' || mode === 'all') ? 1 : 0;
  const ws = (mode === 'speed' || mode === 'all') ? 1 : 0;
  const useSConstraint = (mode === 'damage' && userMinS > 0);
  const tolerance = 0.03 * userMinS;
  const damageThreshold = 1.05;

  let fixedD = 0, fixedDR = 0, fixedS = 0;
  groups.forEach(g => {
    g.ids.forEach(id => {
      const val = document.getElementById(id)?.value;
      if (val && val.includes("-")) {
        const [, i] = val.split("-");
        const t = traitData[g.cat][parseInt(i)];
        fixedD += t.D || 0;
        fixedDR += t.DR || 0;
        fixedS += t.S || 0;
      }
    });
  });

  const corruptStat = document.getElementById("corruptStat").value;
  const corruptValue = parseFloat(document.getElementById("corruptInput").value) || 0;
  if (corruptStat === "Damage") fixedD += corruptValue;
  if (corruptStat === "DR") fixedDR += corruptValue;
  if (corruptStat === "Speed") fixedS += corruptValue;

  for (let i = 0; i < 3; i++) {
    const stat = document.getElementById("geneticStat" + i).value;
    const val = parseFloat(document.getElementById("geneticValue" + i).value) || 0;
    if (stat === "Damage") fixedD += val;
    if (stat === "DR") fixedDR += val;
    if (stat === "Speed") fixedS += val;
  }
  logDebug(`Fixed values: D=${fixedD}, DR=${fixedDR}, S=${fixedS}`);

  let unfixedGroups = [];
  groups.forEach(g => {
    if (g.cat === 'L') return; // Skip Legendary for auto-optimization
    const excluded = Array.from(document.getElementById(`exclude${g.cat}`)?.selectedOptions || []).map(opt => parseInt(opt.value));
    let unfixedIds = [];
    g.ids.forEach((id, slotIndex) => {
      const val = document.getElementById(id)?.value;
      if (!val || !val.includes("-")) {
        unfixedIds.push({id, slotIndex});
      }
    });
    const unfixedCount = unfixedIds.length;
    if (unfixedCount > 0) {
      unfixedGroups.push({...g, unfixedIds, unfixedCount, excluded});
    }
  });

  if (unfixedGroups.length === 0) {
    calculateFinalStats();
    return;
  }

  let fixedCounts = {W:0, N:0, A:0, UW:0, U:0, L:0, P:0, M:0};
  groups.forEach(g => {
    g.ids.forEach(id => {
      if (document.getElementById(id)?.value) fixedCounts[g.cat]++;
    });
  });

  let additionalCounts = {W:0, N:0, A:0, UW:0, U:0, L:0, P:0, M:0};
  unfixedGroups.forEach(g => additionalCounts[g.cat] = g.unfixedCount);

  let finalPossible = {};
  for (let cat in fixedCounts) {
    finalPossible[cat] = fixedCounts[cat] + additionalCounts[cat];
  }

  let canFill = {
    U: finalPossible.N >= 3,
    P: finalPossible.U >= 1,
    M: finalPossible.P >= 1
  };
  logDebug(`Can fill: U=${canFill.U}, P=${canFill.P}, M=${canFill.M}`);

  const groupPriority = {N:0, U:1, P:2, M:3, W:4, A:5, UW:6, L:7};
  unfixedGroups.sort((a, b) => groupPriority[a.cat] - groupPriority[b.cat]);

  let candidates = [];

  function recurse(groupIndex = 0, accD = 0, accDR = 0, accS = 0, choices = {}) {
    if (groupIndex === unfixedGroups.length) {
      const totalD = fixedD + accD;
      const totalDR = fixedDR + accDR;
      const totalS = fixedS + accS;
      candidates.push({d: totalD, dr: totalDR, s: totalS, choices: {...choices}});
      return;
    }
    const g = unfixedGroups[groupIndex];
    const isA = g.cat === 'A';
    const isDependent = ['U','P','M'].includes(g.cat);
    let ks;
    if (isA) {
      ks = Array.from({length: g.unfixedCount + 1}, (_, i) => i);
    } else if (isDependent && !canFill[g.cat]) {
      ks = [0];
    } else {
      ks = [g.unfixedCount];
    }
    ks.forEach(k => {
      if (k === 0) {
        recurse(groupIndex + 1, accD, accDR, accS, {...choices, [g.cat]: {k: 0, combo: []}});
      } else {
        const options = getOptions(g.cat, k, g.excluded);
        options.forEach(opt => {
          recurse(groupIndex + 1, accD + opt.d, accDR + opt.dr, accS + opt.s, {...choices, [g.cat]: {k, combo: opt.combo}});
        });
      }
    });
  }

  recurse();

  if (candidates.length > 0) {
    let dr_filtered = candidates.filter(c => c.dr >= minDR);
    let dr_fallback = dr_filtered.length === 0;
    let considered = dr_fallback ? candidates : dr_filtered;
    let dr_msg = dr_fallback ? ' (DR below 75%; could not reach with available traits)' : '';
    let best = null;
    let msg = '';

    const drSortDir = dr_fallback ? (a, b) => b.dr - a.dr : (a, b) => a.dr - b.dr;

    if (mode === 'damage' && useSConstraint) {
      let above = considered.filter(c => c.s >= userMinS);
      let maxD_above = above.length > 0 ? Math.max(...above.map(c => c.d)) : -Infinity;
      let below = considered.filter(c => c.s < userMinS && c.s >= userMinS - tolerance);
      let qualified_below = below.filter(c => c.d > maxD_above * damageThreshold);
      let s_considered = [...above, ...qualified_below];
      let s_fallback = s_considered.length === 0;
      if (s_fallback) s_considered = considered;
      s_considered.sort((a, b) => b.d - a.d || b.dr - a.dr || a.s - b.s);
      best = s_considered[0];
      let s_msg = '';
      if (!s_fallback && best) {
        const actualS = best.s;
        if (actualS >= userMinS) s_msg = ' (achieved or exceeded)';
        else s_msg = ` (within 3% of desired: actual ${actualS.toFixed(1)}%)`;
      } else {
        s_msg = ' (below desired; no better options found)';
      }
      msg = s_msg + dr_msg;
    } else {
      let sortFunc;
      if (mode === 'damage') sortFunc = (a, b) => b.d - a.d || b.dr - a.dr || a.s - b.s;
      else if (mode === 'speed') sortFunc = (a, b) => b.s - a.s || drSortDir(a, b);
      else sortFunc = (a, b) => (b.d + b.s) - (a.d + a.s) || drSortDir(a, b);
      considered.sort(sortFunc);
      best = considered[0];
      msg = dr_msg;
    }

    document.getElementById('speed-context').innerHTML = msg;
    logDebug(`Optimization message: ${msg}`);

    if (best && best.choices) {
      logDebug("Applying best choices");
      unfixedGroups.forEach(g => {
        const choice = best.choices[g.cat] || {k: 0, combo: []};
        const sortedUnfixed = g.unfixedIds.sort((a, b) => a.slotIndex - b.slotIndex);
        for (let idx = 0; idx < sortedUnfixed.length; idx++) {
          const id = sortedUnfixed[idx].id;
          if (idx < choice.k) {
            document.getElementById(id).value = `${g.cat}-${choice.combo[idx]}`;
          } else {
            document.getElementById(id).value = "";
          }
        }
      });
    }
  } else {
    logDebug("No candidates generated");
  }
  calculateFinalStats();
  logDebug("Optimization completed");
}

function optimizeDamage() { optimize('damage'); }
function optimizeSpeed() { optimize('speed'); }
function optimizeAll() { optimize('all'); }

// Legendary specific optimize
document.getElementById("optDamageLegendary").onclick = function() {
  if (!document.getElementById("Legendary").value) {
    alert("Please select a Legendary trait first!");
    return;
  }
  optimize('damage');
};

// Pygmy sections remain unchanged, no Legendary support

const pygmyGroups = [
  {cat: 'W', maxSlots: 3, startingIds: ['pygmyStartingW1', 'pygmyStartingW2', 'pygmyStartingW3'], addablePrefix: 'pygmyAddW'},
  {cat: 'N', maxSlots: 3, startingIds: ['pygmyStartingN1', 'pygmyStartingN2', 'pygmyStartingN3'], addablePrefix: 'pygmyAddN'},
  {cat: 'A', maxSlots: 3, startingIds: [], addablePrefix: 'pygmyAddA'},
  {cat: 'UW', maxSlots: 1, startingIds: ['pygmyStartingUW'], addablePrefix: 'pygmyAddUW'},
  {cat: 'U', maxSlots: 1, startingIds: [], addablePrefix: 'pygmyAddU'},
  {cat: 'P', maxSlots: 1, startingIds: ['pygmyStartingPrime'], addablePrefix: 'pygmyAddPrime'},
  {cat: 'M', maxSlots: 1, startingIds: ['pygmyStartingMega'], addablePrefix: 'pygmyAddMega'}
];

function populatePygmyDropdowns() {
  logDebug("Populating pygmy dropdowns");
  pygmyGroups.forEach(g => {
    g.startingIds.forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        select.innerHTML = '<option value="">--None--</option>';
        traitData[g.cat].forEach((t, i) => {
          const opt = document.createElement('option');
          opt.value = i;
          opt.text = t.N;
          select.appendChild(opt);
        });
      }
    });
  });

  for (const cat in traitData) {
    if (cat === 'L') continue; // No Legendary for Pygmy
    const excludeSelect = document.getElementById(`pygmyExclude${cat}`);
    if (excludeSelect) {
      excludeSelect.innerHTML = "";
      traitData[cat].forEach((t, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = t.N;
        excludeSelect.appendChild(opt);
      });
    }
  }
}

function updatePygmyAddableSlots() {
  logDebug("Updating pygmy addable slots");
  const container = document.getElementById('pygmyAddableTraits');
  container.innerHTML = '';
  let hasPrime = document.getElementById('pygmyStartingPrime').value !== '';
  let hasMega = document.getElementById('pygmyStartingMega').value !== '';
  if (hasMega && !hasPrime) {
    alert("If a Pygmy has a Mega trait, it must also have a Prime trait. Please select a Prime trait.");
    document.getElementById('pygmyStartingMega').value = '';
    hasMega = false;
  }
  const leftColumn = document.createElement('div');
  leftColumn.className = 'addable-column';
  const rightColumn = document.createElement('div');
  rightColumn.className = 'addable-column';
  let columnIndex = 0;
  pygmyGroups.forEach(g => {
    if ((g.cat === 'P' && hasPrime) || (g.cat === 'M' && hasMega)) return;
    const occupied = g.startingIds.filter(id => document.getElementById(id)?.value !== '').length;
    const available = g.maxSlots - occupied;
    if (available > 0) {
      const h4 = document.createElement('h4');
      h4.textContent = `Addable ${g.cat} – Up to ${available}`;
      (columnIndex % 2 === 0 ? leftColumn : rightColumn).appendChild(h4);
      for (let i = 1; i <= available; i++) {
        const select = document.createElement('select');
        select.id = `${g.addablePrefix}${i}`;
        select.innerHTML = '<option value="">--Select--</option>';
        traitData[g.cat].forEach((t, idx) => {
          const opt = document.createElement('option');
          opt.value = `${g.cat}-${idx}`;
          let parts = [];
          if (t.D !== 0) parts.push(`DMG ${t.D > 0 ? '+' : ''}${t.D}`);
          if (t.DR !== 0) parts.push(`DR ${t.DR > 0 ? '+' : ''}${t.DR}`);
          if (t.S !== 0) parts.push(`SPD ${t.S > 0 ? '+' : ''}${t.S}`);
          opt.text = `${t.N}${parts.length > 0 ? ` (${parts.join(', ')})` : ''}`;
          select.appendChild(opt);
        });
        select.addEventListener('change', calculatePygmyFinalStats);
        (columnIndex % 2 === 0 ? leftColumn : rightColumn).appendChild(select);
      }
      columnIndex++;
    }
  });
  container.appendChild(leftColumn);
  container.appendChild(rightColumn);
  calculatePygmyFinalStats();
}

function getPygmyCurrentTotals() {
  let total = {
    Damage: parseFloat(document.getElementById('pygmyStartingDmg').value) || 0,
    DR: parseFloat(document.getElementById('pygmyStartingDR').value) || 0,
    Speed: parseFloat(document.getElementById('pygmyStartingSpd').value) || 0
  };
  pygmyGroups.forEach(g => {
    for (let i = 1; i <= g.maxSlots; i++) {
      const id = `${g.addablePrefix}${i}`;
      const val = document.getElementById(id)?.value;
      if (val && val.includes('-')) {
        const [cat, idx] = val.split('-');
        const t = traitData[cat][parseInt(idx)];
        total.Damage += t.D || 0;
        total.DR += t.DR || 0;
        total.Speed += t.S || 0;
      }
    }
  });
  return total;
}

function calculatePygmyFinalStats() {
  const total = getPygmyCurrentTotals();
  let drPercent = total.DR;
  let drWarning = '';
  if (drPercent > 75) {
    drWarning = ` <span class="warning">(${(drPercent - 75).toFixed(1)}% over cap)</span>`;
    drPercent = Math.min(drPercent, 75);
  }
  const dmg = 1 + total.Damage / 100, dr = 1 - drPercent / 100, spd = 1 + total.Speed / 100;
  let out = isMultiplierView ?
    `Pygmy Bonus: Damage: ${dmg.toFixed(3)}, DR: ${dr.toFixed(3)}${drWarning}, SPD: ${spd.toFixed(3)}` :
    `Pygmy Bonus: Damage: ${total.Damage.toFixed(1)}%, DR: ${drPercent.toFixed(1)}%${drWarning}, SPD: ${total.Speed.toFixed(1)}%`;
  document.getElementById('pygmyFinalResult').innerHTML = out;
}

function pygmyOptimize(mode) {
  logDebug(`Starting pygmy optimization for mode: ${mode}`);
  document.getElementById('pygmySpeedContext').innerHTML = '';
  const minDR = 75;
  const userMinS = parseFloat(document.getElementById('pygmyMinSpeed').value) || 0;
  const wd = (mode === 'damage' || mode === 'all') ? 1 : 0;
  const ws = (mode === 'speed' || mode === 'all') ? 1 : 0;
  const useSConstraint = (mode === 'damage' && userMinS > 0);
  const tolerance = 0.03 * userMinS;
  const damageThreshold = 1.05;

  let fixedD = parseFloat(document.getElementById('pygmyStartingDmg').value) || 0;
  let fixedDR = parseFloat(document.getElementById('pygmyStartingDR').value) || 0;
  let fixedS = parseFloat(document.getElementById('pygmyStartingSpd').value) || 0;

  let unfixedGroups = [];
  pygmyGroups.forEach(g => {
    const excluded = Array.from(document.getElementById(`pygmyExclude${g.cat}`)?.selectedOptions || []).map(opt => parseInt(opt.value));
    const occupied = g.startingIds.filter(id => document.getElementById(id)?.value !== '').length;
    const unfixedCount = g.maxSlots - occupied;
    let unfixedIds = [];
    for (let i = 1; i <= unfixedCount; i++) {
      unfixedIds.push({id: `${g.addablePrefix}${i}`, slotIndex: i - 1});
    }
    if (unfixedCount > 0) {
      unfixedGroups.push({...g, unfixedIds, unfixedCount, excluded});
    }
  });

  if (unfixedGroups.length === 0) {
    calculatePygmyFinalStats();
    return;
  }

  let fixedCounts = {W:0, N:0, A:0, UW:0, U:0, P:0, M:0};
  pygmyGroups.forEach(g => {
    g.startingIds.forEach(id => {
      if (document.getElementById(id)?.value !== '') fixedCounts[g.cat]++;
    });
  });

  let additionalCounts = {W:0, N:0, A:0, UW:0, U:0, P:0, M:0};
  unfixedGroups.forEach(g => additionalCounts[g.cat] = g.unfixedCount);

  let finalPossible = {};
  for (let cat in fixedCounts) {
    finalPossible[cat] = fixedCounts[cat] + additionalCounts[cat];
  }

  let canFill = {
    U: finalPossible.N >= 3,
    P: finalPossible.U >= 1,
    M: finalPossible.P >= 1
  };

  const groupPriority = {N:0, U:1, P:2, M:3, W:4, A:5, UW:6};
  unfixedGroups.sort((a, b) => groupPriority[a.cat] - groupPriority[b.cat]);

  let candidates = [];

  function pygmyRecurse(groupIndex = 0, accD = 0, accDR = 0, accS = 0, choices = {}) {
    if (groupIndex === unfixedGroups.length) {
      const totalD = fixedD + accD;
      const totalDR = fixedDR + accDR;
      const totalS = fixedS + accS;
      candidates.push({d: totalD, dr: totalDR, s: totalS, choices: {...choices}});
      return;
    }
    const g = unfixedGroups[groupIndex];
    const isA = g.cat === 'A';
    const isDependent = ['U','P','M'].includes(g.cat);
    let ks;
    if (isA) {
      ks = Array.from({length: g.unfixedCount + 1}, (_, i) => i);
    } else if (isDependent && !canFill[g.cat]) {
      ks = [0];
    } else {
      ks = [g.unfixedCount];
    }
    ks.forEach(k => {
      if (k === 0) {
        pygmyRecurse(groupIndex + 1, accD, accDR, accS, {...choices, [g.cat]: {k: 0, combo: []}});
      } else {
        const options = getOptions(g.cat, k, g.excluded);
        options.forEach(opt => {
          pygmyRecurse(groupIndex + 1, accD + opt.d, accDR + opt.dr, accS + opt.s, {...choices, [g.cat]: {k, combo: opt.combo}});
        });
      }
    });
  }

  pygmyRecurse();

  if (candidates.length > 0) {
    let dr_filtered = candidates.filter(c => c.dr >= minDR);
    let dr_fallback = dr_filtered.length === 0;
    let considered = dr_fallback ? candidates : dr_filtered;
    let dr_msg = dr_fallback ? ' (DR below 75%; could not reach with available traits)' : '';
    let best = null;
    let msg = dr_msg;

    const drSortDir = dr_fallback ? (a, b) => b.dr - a.dr : (a, b) => a.dr - b.dr;

    if (mode === 'damage' && useSConstraint) {
      let above = considered.filter(c => c.s >= userMinS);
      let maxD_above = above.length > 0 ? Math.max(...above.map(c => c.d)) : -Infinity;
      let below = considered.filter(c => c.s < userMinS && c.s >= userMinS - tolerance);
      let qualified_below = below.filter(c => c.d > maxD_above * damageThreshold);
      let s_considered = [...above, ...qualified_below];
      let s_fallback = s_considered.length === 0;
      if (s_fallback) s_considered = considered;
      s_considered.sort((a, b) => b.d - a.d || b.dr - a.dr || a.s - b.s);
      best = s_considered[0];
      let s_msg = '';
      if (!s_fallback && best) {
        const actualS = best.s;
        if (actualS >= userMinS) s_msg = ' (achieved or exceeded)';
        else s_msg = ` (within 3% of desired: actual ${actualS.toFixed(1)}%)`;
      } else {
        s_msg = ' (below desired; no better options found)';
      }
      msg = s_msg + dr_msg;
    } else {
      let sortFunc;
      if (mode === 'damage') sortFunc = (a, b) => b.d - a.d || b.dr - a.dr || a.s - b.s;
      else if (mode === 'speed') sortFunc = (a, b) => b.s - a.s || drSortDir(a, b);
      else sortFunc = (a, b) => (b.d + b.s) - (a.d + a.s) || drSortDir(a, b);
      considered.sort(sortFunc);
      best = considered[0];
    }

    document.getElementById('pygmySpeedContext').innerHTML = msg;

    if (best && best.choices) {
      unfixedGroups.forEach(g => {
        const choice = best.choices[g.cat] || {k: 0, combo: []};
        const sortedUnfixed = g.unfixedIds.sort((a, b) => a.slotIndex - b.slotIndex);
        for (let idx = 0; idx < sortedUnfixed.length; idx++) {
          const id = sortedUnfixed[idx].id;
          if (idx < choice.k) {
            document.getElementById(id).value = `${g.cat}-${choice.combo[idx]}`;
          } else {
            document.getElementById(id).value = "";
          }
        }
      });
    }
  }
  calculatePygmyFinalStats();
}

// Initialize
populateDropdowns();
populatePygmyDropdowns();
updateSavedDropdown();
calculateFinalStats();
loadFromUrl();
updatePygmyAddableSlots();

// Event Listeners
document.getElementById("toggleTheme").onclick = function(){
  document.body.classList.toggle("dark-mode");
  this.textContent = document.body.classList.contains("dark-mode") ? "Switch to Light Mode" : "Switch to Dark Mode";
};
document.getElementById("saveBuild").onclick = saveBuild;
document.getElementById("loadBuild").onclick = loadBuild;
document.getElementById("deleteBuild").onclick = deleteBuild;
document.getElementById("optDamage").onclick = optimizeDamage;
document.getElementById("optSpeed").onclick = optimizeSpeed;
document.getElementById("optAll").onclick = optimizeAll;
document.getElementById("clearOptimized").onclick = clearOptimizedTraits;
document.getElementById("clearAll").onclick = clearAll;

const autoCalcElements = document.querySelectorAll('select:not(#savedBuilds):not([id^="exclude"]), input[type="number"]');
autoCalcElements.forEach(el => {
  el.addEventListener('change', calculateFinalStats);
  el.addEventListener('input', calculateFinalStats);
});

const pygmyStartingElements = document.querySelectorAll('#pygmyTraitPlanner [id^="pygmyStarting"]');
pygmyStartingElements.forEach(el => {
  if (el.tagName === 'SELECT' || el.type === 'number') {
    el.addEventListener('change', () => { updatePygmyAddableSlots(); calculatePygmyFinalStats(); });
    if (el.type === 'number') el.addEventListener('input', () => { updatePygmyAddableSlots(); calculatePygmyFinalStats(); });
  }
});

const pygmyOtherElements = document.querySelectorAll('#pygmyTraitPlanner input:not([id^="pygmyStarting"]), #pygmyTraitPlanner select:not([id^="pygmyStarting"]):not([id^="pygmyAdd"]):not([id^="pygmyExclude"])');
pygmyOtherElements.forEach(el => {
  el.addEventListener('change', calculatePygmyFinalStats);
  if (el.type === 'number') el.addEventListener('input', calculatePygmyFinalStats);
});

document.getElementById('pygmyOptDamage').onclick = () => pygmyOptimize('damage');
document.getElementById('pygmyOptSpeed').onclick = () => pygmyOptimize('speed');
document.getElementById('pygmyOptAll').onclick = () => pygmyOptimize('all');

document.getElementById('toggleView').addEventListener('click', () => {
  isMultiplierView = !isMultiplierView;
  calculateFinalStats();
  calculatePygmyFinalStats();
});

// Enforce ranges
function enforceRange(input, min, max) {
  input.addEventListener('input', function() {
    let val = parseFloat(this.value);
    if (isNaN(val)) this.value = '';
    else {
      if (val < min) this.value = min;
      if (val > max) this.value = max;
    }
  });
}
enforceRange(document.getElementById('corruptInput'), -25, 25);
enforceRange(document.getElementById('geneticValue0'), 5, 10);
enforceRange(document.getElementById('geneticValue1'), 5, 10);
enforceRange(document.getElementById('geneticValue2'), 5, 10);
enforceRange(document.getElementById('traitCleanseCounter'), 1, 5);
enforceRange(document.getElementById('absoluteTraitCleanseCounter'), 1, 3);

// Debug Log Controls
document.getElementById("refreshLog").onclick = () => {
  document.getElementById("debugLog").value = debugLogs.join("\n");
};
document.getElementById("copyLog").onclick = () => {
  navigator.clipboard.writeText(debugLogs.join("\n")).then(() => alert("Debug log copied!")).catch(() => alert("Copy failed."));
};
document.getElementById("clearLog").onclick = () => {
  debugLogs = [];
  document.getElementById("debugLog").value = "";
};
</script>
</body>
</html>
