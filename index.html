<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Raven’s Dox2 Trait Planner</title>
<style>
:root {
  --bg-color: #f0f0f0;
  --section-bg: #fff;
  --result-bg: #cfe0ff;
  --sticky-bg: #e0e0ff;
  --text-color: #000;
}
body { font-family: Arial, sans-serif; padding:20px; background: var(--bg-color); color: var(--text-color); margin:0;}
h1 {text-align:center; font-size:36px; margin-bottom:10px;}
h2 { font-size:28px; margin-top:0;}
.section { background: var(--section-bg); padding:20px; margin-bottom:20px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.1);}
label { display:block; margin-top:10px; font-size:20px; }
select, input[type=number], input[type=text] { margin:10px 0; padding:10px; width:100%; font-size:20px;}
.sticky-header { position: sticky; top:0; background: var(--sticky-bg); padding:15px 20px; z-index:999; border-bottom:2px solid #999; box-shadow:0 4px 6px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 10px;}
.header-top { display: flex; align-items: center; gap: 10px; }
.header-top h2 { margin: 0; }
.header-top .result { flex-grow: 1; margin: 0; font-size: 20px; padding: 10px; } /* Adjusted padding */
.header-bottom { display: flex; justify-content: center; gap: 10px; }
.header-bottom .clear-buttons { display: flex; gap: 5px; }
.header-bottom .clear-buttons button, .header-bottom button#toggleView { font-size: 16px; padding: 8px 16px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; white-space: nowrap; }
body.dark-mode .header-bottom .clear-buttons button, body.dark-mode .header-bottom button#toggleView { background-color: #495057; }
.result { background: var(--result-bg); padding:15px; border-radius:5px; margin-top:10px; font-weight:bold; font-size:24px;}
.warning { color:red; font-weight:bold; }
.flex-row { display:flex; gap:10px; flex-wrap:wrap; }
.flex-row select, .flex-row input[type=number] { flex:1; }
@media(max-width:600px){h1{font-size:28px;}h2{font-size:22px;} select,input[type=number],input[type=text]{font-size:18px;}}
body.dark-mode {--bg-color:#1c1c1c;--section-bg:#2c2c2c;--result-bg:#3a3a5c;--sticky-bg:#3a3a5c;--text-color:#f0f0f0;}
#toggleTheme {font-size:20px; padding:14px 28px; border-radius:12px; cursor:pointer; background-color:#4a90e2; color:#fff; border:none; margin-bottom:20px;}

/* Collapsible Calculator */
.calc-widget { position: fixed; bottom: 10px; right: 10px; width: 220px; background: var(--section-bg); box-shadow:0 4px 10px rgba(0,0,0,0.2); border-radius:10px; padding:10px; z-index:2000; display:none;}
.calc-display { width:100%; height:40px; font-size:20px; margin-bottom:8px; text-align:right; padding:5px;}
.calc-buttons { display:grid; grid-template-columns: repeat(4,1fr); gap:5px;}
.calc-buttons button { padding:12px; font-size:18px; border-radius:6px; border:none; cursor:pointer;}
#toggleCalc {position: fixed; bottom: 10px; right: 10px; z-index:3000; background:#4a90e2; color:#fff; border:none; border-radius:10px; padding:10px 15px; font-size:16px; cursor:pointer;}
@media(max-width:900px){.calc-widget{width:180px; right:10px; bottom:50px;}}

/* Exclusions */
.exclusions { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }
.exclusions label { font-size: 18px; }
.exclusions select { height: 120px; font-size: 16px; } /* Bigger box, smaller font */

/* Optimize buttons */
.optimize-buttons { display: flex; justify-content: center; gap: 10px; flex-wrap: nowrap; margin-top: 20px; }
.optimize-buttons button[id^="opt"] { font-size: 30px; padding: 19px 38px; } /* 25% bigger */
@media (max-width: 1200px) {
  .optimize-buttons { flex-wrap: wrap; justify-content: center; }
  .optimize-buttons button[id^="opt"] { font-size: 24px; padding: 15px 30px; }
}

/* Combined sections */
.combined-section { display: flex; gap: 20px; flex-wrap: wrap; }
.combined-section > div { flex: 1; min-width: 200px; }
.combined-section select { width: 100%; padding: 5px; font-size: 16px; } /* Half size */
.combined-section label { font-size: 18px; }
.combined-section input[type=number] { width: 100%; padding: 5px; font-size: 16px; }
.combined-section h4 { font-size: 20px; margin-bottom: 10px; }
.combined-section .addable-column { flex: 1; min-width: 200px; }
</style>
</head>
<body class="dark-mode">

<h1>Raven’s Dox2 Trait Planner</h1>
<div style="text-align:center;"><button id="toggleTheme">Switch to Light Mode</button></div>

<div class="section sticky-header">
<div class="header-top">
<h2>Trait Power %</h2>
<div class="result" id="finalResult">Damage: 1.0, DR: 1.0, SPD: 1.0</div>
</div>
<div class="header-bottom">
<button id="toggleView">Swap Trait Power View</button>
<div class="clear-buttons">
<button id="clearOptimized">Clear Optimized</button>
<button id="clearAll">Clear All</button>
</div>
</div>
</div>

<div class="section combined-section">
<div>
<h2>Corrupt and Greaters</h2>
<div class="flex-row">
<label>Corrupt String Stat:
<select id="corruptStat"></select></label>
<label>Bonus (%): <input type="number" id="corruptInput" min="-25" max="25" placeholder="Enter -25 to 25%"></label>
</div>
<div class="flex-row">
<label>Greater String 1 Stat:
<select id="geneticStat0"></select></label>
<label>Bonus (%): <input type="number" id="geneticValue0" min="5" max="10" placeholder="Enter 5-10%"></label>
</div>
<div class="flex-row">
<label>Greater String 2 Stat:
<select id="geneticStat1"></select></label>
<label>Bonus (%): <input type="number" id="geneticValue1" min="5" max="10" placeholder="Enter 5-10%"></label>
</div>
<div class="flex-row">
<label>Greater String 3 Stat:
<select id="geneticStat2"></select></label>
<label>Bonus (%): <input type="number" id="geneticValue2" min="5" max="10" placeholder="Enter 5-10%"></label>
</div>
</div>
<div>
<h2>Cleanse Counters</h2>
<div class="flex-row">
<label>Trait Cleanse Counter:
<input type="number" id="traitCleanseCounter" min="1" max="5" placeholder="Enter 1-5"></label>
</div>
<div class="flex-row">
<label>Absolute Trait Cleanse Counter:
<input type="number" id="absoluteTraitCleanseCounter" min="1" max="3" placeholder="Enter 1-3"></label>
</div>
</div>
</div>

<div class="section">
<h2>Calculate Final HP</h2>
<input type="number" id="targetHP" placeholder="Enter Desired Final HP after Prime and Mega traits added" style="width: 33%; padding: 5px; font-size: 16px;">
</div>

<div class="section combined-section">
<div>
<h2>Prime & Mega Traits</h2>
<label>Prime Trait:<select id="Prime"></select></label>
<label>Mega Trait:<select id="Mega"></select></label>
</div>
<div>
<h2>Artificial Traits (A) – Max 3</h2>
<select id="A1"></select>
<select id="A2"></select>
<select id="A3"></select>
</div>
</div>

<div class="section combined-section">
<div>
<h2>Wild Traits (W) – Max 3</h2>
<select id="W1"></select>
<select id="W2"></select>
<select id="W3"></select>
</div>
<div>
<h2>Natural Traits (N) – Max 3</h2>
<select id="N1"></select>
<select id="N2"></select>
<select id="N3"></select>
</div>
</div>

<div class="section combined-section">
<div>
<h2>Unique Wild (UW)</h2>
<select id="UW"></select>
</div>
<div>
<h2>Unique (U)</h2>
<select id="U"></select>
</div>
</div>

<div class="section">
<h2>Build Management</h2>
<input type="text" id="buildName" placeholder="Build Name" style="width: 33%; padding: 5px; font-size: 16px;">
<button id="saveBuild">Save Build</button>
<select id="savedBuilds" style="width: 33%; padding: 5px; font-size: 16px;"></select>
<button id="loadBuild">Load Build</button>
<button id="deleteBuild">Delete Build</button>
<button id="shareBuild">Share Build</button>
</div>

<div class="section">
<h2>Optimize Build</h2>
<label>Minimum Desired Speed %: <input type="number" id="minSpeed" placeholder="e.g., 20" step="0.1" style="width: 33%; padding: 5px; font-size: 16px;"><span id="speed-context"></span></label>
<h2>Exclusions</h2>
<p>Use exclusions if you are missing some traits and don’t want them to be considered</p>
<div class="exclusions">
<label>Exclude W: <select id="excludeW" multiple></select></label>
<label>Exclude N: <select id="excludeN" multiple></select></label>
<label>Exclude A: <select id="excludeA" multiple></select></label>
<label>Exclude UW: <select id="excludeUW" multiple></select></label>
<label>Exclude U: <select id="excludeU" multiple></select></label>
<label>Exclude Prime: <select id="excludeP" multiple></select></label>
<label>Exclude Mega: <select id="excludeM" multiple></select></label>
</div>
<div class="optimize-buttons">
<button id="optDamage">Optimize for Damage</button>
<button id="optSpeed">Optimize for Speed</button>
<button id="optAll">Optimize for Least Waste</button>
</div>
</div>

<div class="section" id="pygmyTraitPlanner">
<h2>Pygmy Trait Planner</h2>
<p>Feed the corrupt and greater strings to your pygmy if desired, then enter your Pygmy's starting traits (for slot tracking) and current total % bonuses below. The planner will suggest optimal additions.</p>

<!-- Starting Traits and Totals -->
<h3>Starting Traits and Current Totals</h3>
<label>Current Damage %: <input type="number" id="pygmyStartingDmg" placeholder="Enter current DMG %" style="width: 33%; padding: 5px; font-size: 16px;"></label>
<label>Current DR %: <input type="number" id="pygmyStartingDR" placeholder="Enter current DR %" style="width: 33%; padding: 5px; font-size: 16px;"></label>
<label>Current Speed %: <input type="number" id="pygmyStartingSpd" placeholder="Enter current SPD %" style="width: 33%; padding: 5px; font-size: 16px;"></label>

<div class="combined-section">
<div>
<h4>Starting Wild Traits (W) – Up to 3</h4>
<select id="pygmyStartingW1"></select>
<select id="pygmyStartingW2"></select>
<select id="pygmyStartingW3"></select>
</div>
<div>
<h4>Starting Natural Traits (N) – Up to 3</h4>
<select id="pygmyStartingN1"></select>
<select id="pygmyStartingN2"></select>
<select id="pygmyStartingN3"></select>
</div>
</div>

<div class="combined-section">
<div>
<h4>Starting Unique Wild (UW)</h4>
<select id="pygmyStartingUW"></select>
</div>
<div>
<h4>Starting Prime (P)</h4>
<select id="pygmyStartingPrime"></select>
<h4>Starting Mega (M)</h4>
<select id="pygmyStartingMega"></select>
</div>
</div>

<!-- Addable Traits -->
<h3>Addable Traits</h3>
<p>If your Pygmy already has a P or M trait, it is not possible to add any new P or M traits.</p>
<div class="combined-section" id="pygmyAddableTraits">
<!-- Dynamically populated via JS, now in 2 columns -->
</div>

<!-- Exclusions for Additions -->
<h3>Exclusions for Additions</h3>
<div class="exclusions">
<label>Exclude W: <select id="pygmyExcludeW" multiple></select></label>
<label>Exclude N: <select id="pygmyExcludeN" multiple></select></label>
<label>Exclude A: <select id="pygmyExcludeA" multiple></select></label>
<label>Exclude UW: <select id="pygmyExcludeUW" multiple></select></label>
<label>Exclude U: <select id="pygmyExcludeU" multiple></select></label>
<label>Exclude Prime: <select id="pygmyExcludeP" multiple></select></label>
<label>Exclude Mega: <select id="pygmyExcludeM" multiple></select></label>
</div>

<label>Minimum Desired Speed %: <input type="number" id="pygmyMinSpeed" placeholder="e.g., 20" step="0.1" style="width: 33%; padding: 5px; font-size: 16px;"><span id="pygmySpeedContext"></span></label>

<div class="optimize-buttons">
<button id="pygmyOptDamage">Optimize for Damage</button>
<button id="pygmyOptSpeed">Optimize for Speed</button>
<button id="pygmyOptAll">Optimize for Least Waste</button>
</div>

<div class="result" id="pygmyFinalResult">Pygmy Bonus: Damage: 1.0, DR: 1.0, SPD: 1.0</div>
<button id="pygmyToggleView">Swap View</button>
</div>

<!-- Collapsible Calculator -->
<button id="toggleCalc">Show Calculator</button>
<div class="calc-widget" id="calcWidget">
<input type="text" class="calc-display" id="calcDisplay" readonly>
<div class="calc-buttons">
<button onclick="calcPress('7')">7</button><button onclick="calcPress('8')">8</button><button onclick="calcPress('9')">9</button><button onclick="calcPress('/')">÷</button>
<button onclick="calcPress('4')">4</button><button onclick="calcPress('5')">5</button><button onclick="calcPress('6')">6</button><button onclick="calcPress('*')">×</button>
<button onclick="calcPress('1')">1</button><button onclick="calcPress('2')">2</button><button onclick="calcPress('3')">3</button><button onclick="calcPress('-')">−</button>
<button onclick="calcPress('0')">0</button><button onclick="calcPress('.')">.</button><button onclick="calcClear()">C</button><button onclick="calcPress('+')">+</button>
<button style="grid-column: span 4; background:#4a90e2; color:white;" onclick="calcEquals()">=</button>
</div>
</div>

<!-- Debug Log Section -->
<div class="section">
<h2>Debug Log</h2>
<textarea id="debugLog" readonly style="width:100%; height:200px; font-size:14px;"></textarea>
<div style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
<button id="refreshLog">Refresh Log</button>
<button id="copyLog">Copy Log to Clipboard</button>
<button id="clearLog">Clear Log</button>
</div>
</div>

<script>
// Debug Log Setup
let debugLogs = [];
function logDebug(message) {
  const timestamp = new Date().toLocaleString();
  debugLogs.push(`[${timestamp}] ${message}`);
}
window.onerror = function(message, source, lineno, colno, error) {
  logDebug(`Error: ${message} at line ${lineno}:${colno}`);
  return false; // Allow default handling if desired
};

// ---------------------------
// TRAIT DATABASE
// ---------------------------
const traitData={
"W":[{N:"Tough",D:10,DR:10,S:-5},{N:"Balanced",D:7.5,DR:5,S:5},{N:"Runner",D:-5,DR:0,S:15},{N:"Brawler",D:15,DR:2.5,S:-5}],
"N":[{N:"Tough",D:0,DR:15,S:-5},{N:"Balanced",D:5,DR:0,S:5},{N:"Runner",D:-5,DR:0,S:10},{N:"Brawler",D:10,DR:5,S:-5}],
"A":[{N:"Tough",D:0,DR:5,S:-2.5},{N:"Balanced",D:2.5,DR:0,S:2.5},{N:"Runner",D:0,DR:0,S:5},{N:"Brawler",D:5,DR:2.5,S:-2.5}],
"UW":[{N:"Tough",D:15,DR:7.5,S:-5},{N:"Balanced",D:10,DR:5,S:5},{N:"Runner",D:-5,DR:0,S:15},{N:"Juggernaut",D:12.5,DR:10,S:-2.5}],
"U":[{N:"Tough",D:5,DR:15,S:-2.5},{N:"Balanced",D:10,DR:0,S:10},{N:"Runner",D:-5,DR:0,S:15},{N:"Juggernaut",D:15,DR:10,S:-5}],
"P":[{N:"Tough",D:15,DR:20,S:0},{N:"Balanced",D:20,DR:0,S:5},{N:"Runner",D:0,DR:0,S:25},{N:"Juggernaut",D:25,DR:15,S:-5}],
"M":[{N:"Tough",D:15,DR:25,S:0},{N:"Balanced",D:25,DR:0,S:7.5},{N:"Runner",D:0,DR:0,S:15},{N:"Juggernaut",D:30,DR:20,S:-5}]
};

// ---------------------------
// POPULATE DROPDOWNS
// ---------------------------
function populateDropdowns(){
  logDebug("Populating dropdowns");
  const mapping={W:["W1","W2","W3"],N:["N1","N2","N3"],A:["A1","A2","A3"],UW:["UW"],U:["U"],P:["Prime"],M:["Mega"]};
  for(const cat in mapping){
    mapping[cat].forEach(id=>{
      const select=document.getElementById(id);
      select.innerHTML="";
      const empty=document.createElement("option");
      empty.value=""; empty.textContent="--Select--"; select.appendChild(empty);
      traitData[cat].forEach((t,i)=>{
        const opt=document.createElement("option");
        opt.value=`${cat}-${i}`;
        let parts=[];
        if(t.D!==0) parts.push(`DMG ${t.D>0?"+":""}${t.D}`);
        if(t.DR!==0) parts.push(`DR ${t.DR>0?"+":""}${t.DR}`);
        if(t.S!==0) parts.push(`SPD ${t.S>0?"+":""}${t.S}`);
        opt.text=`${t.N}${parts.length>0?` (${parts.join(", ")})`:""}`;
        select.appendChild(opt);
      });
    });
  }

  for(let i=0;i<3;i++){
    const select=document.getElementById("geneticStat"+i);
    select.innerHTML="";
    const empty=document.createElement("option"); empty.value=""; empty.textContent="--Select Stat--"; select.appendChild(empty);
    ["Damage","DR","Speed"].forEach(stat=>{
      const opt=document.createElement("option"); opt.value=stat; opt.textContent=stat; select.appendChild(opt);
    });
  }

  const corruptSelect = document.getElementById("corruptStat");
  corruptSelect.innerHTML="";
  const corruptEmpty = document.createElement("option"); corruptEmpty.value=""; corruptEmpty.textContent="--Select Stat--"; corruptSelect.appendChild(corruptEmpty);
  ["Damage","DR","Speed"].forEach(stat=>{
    const opt=document.createElement("option"); opt.value=stat; opt.textContent=stat; corruptSelect.appendChild(opt);
  });

  // Populate exclude selects
  for(const cat in traitData){
    const excludeSelect = document.getElementById(`exclude${cat}`);
    if(excludeSelect) {
      excludeSelect.innerHTML = "";
      traitData[cat].forEach((t, i) => {
        const opt=document.createElement("option");
        opt.value = i;
        opt.textContent = t.N;
        excludeSelect.appendChild(opt);
      });
    }
  }
}

// ---------------------------
// GET CURRENT TOTALS
// ---------------------------
function getCurrentTotals() {
  logDebug("Calculating current totals");
  let total = {Damage: 0, DR: 0, Speed: 0};
  ["W1","W2","W3","N1","N2","N3","A1","A2","A3","UW","U","Prime","Mega"].forEach(id => {
    const val = document.getElementById(id).value;
    if (val.includes("-")) {
      const [cat, i] = val.split("-");
      const t = traitData[cat][parseInt(i)];
      total.Damage += t.D || 0;
      total.DR += t.DR || 0;
      total.Speed += t.S || 0;
    }
  });
  const corrupt = document.getElementById("corruptStat").value;
  total[corrupt] += parseFloat(document.getElementById("corruptInput").value) || 0;
  for (let i = 0; i < 3; i++) {
    const stat = document.getElementById("geneticStat" + i).value;
    const val = parseFloat(document.getElementById("geneticValue" + i).value) || 0;
    if (stat) total[stat] += val;
  }
  return total;
}

// ---------------------------
// CALCULATE DINO TRAIT POWER
// ---------------------------
let isMultiplierView = true;
function calculateFinalStats(){
  logDebug("Calculating final stats");
  const total = getCurrentTotals();
  let drPercent=total.DR;
  let drWarning="";
  if(drPercent>75){ drWarning=` <span class="warning">(${(drPercent-75).toFixed(1)}% over cap)</span>`; drPercent=Math.min(drPercent,75);}
  const dmg=1+total.Damage/100, dr=1-drPercent/100, spd=1+total.Speed/100;
  let out;
  if(isMultiplierView){
    out=`Damage: ${dmg.toFixed(3)}, DR: ${dr.toFixed(3)}${drWarning}, SPD: ${spd.toFixed(3)}`;
  }else{
    out=`Damage: ${total.Damage.toFixed(1)}%, DR: ${drPercent.toFixed(1)}%${drWarning}, SPD: ${total.Speed.toFixed(1)}%`;
  }
  const target=parseFloat(document.getElementById("targetHP").value);
  if(target){const prime=1.25, mega=1.40; out+=`<br><b>Level HP to ~</b>${Math.round(target/(prime*mega))} before Prime & Mega`;}
  document.getElementById("finalResult").innerHTML=out;
}

// ---------------------------
// SIMPLE CALCULATOR
// ---------------------------
const calcDisplay=document.getElementById("calcDisplay");
function calcPress(v){calcDisplay.value+=v;}
function calcClear(){calcDisplay.value="";}
function calcEquals(){try{calcDisplay.value=eval(calcDisplay.value);}catch{calcDisplay.value="Error";}}
document.getElementById("toggleCalc").onclick=()=>{
  const w=document.getElementById("calcWidget");
  const btn=document.getElementById("toggleCalc");
  if(w.style.display==="block"){w.style.display="none"; btn.textContent="Show Calculator";}
  else{w.style.display="block"; btn.textContent="Hide Calculator";}
};

// ---------------------------
// SAVE/LOAD BUILDS
// ---------------------------
let savedBuilds = JSON.parse(localStorage.getItem("savedBuilds")) || {};
function saveBuild(){
  logDebug("Saving build");
  const name=document.getElementById("buildName").value.trim();
  if(!name)return alert("Enter build name!");
  savedBuilds[name]={};
  ["W1","W2","W3","N1","N2","N3","A1","A2","A3","UW","U","Prime","Mega","corruptStat","corruptInput","geneticStat0","geneticStat1","geneticStat2","geneticValue0","geneticValue1","geneticValue2","targetHP","traitCleanseCounter","absoluteTraitCleanseCounter"].forEach(id=>{
    savedBuilds[name][id]=document.getElementById(id).value;
  });
  localStorage.setItem("savedBuilds", JSON.stringify(savedBuilds));
  updateSavedDropdown();
}
function updateSavedDropdown(){
  const sel=document.getElementById("savedBuilds"); sel.innerHTML="";
  Object.keys(savedBuilds).forEach(name=>{
    const opt=document.createElement("option"); opt.value=name; opt.textContent=name; sel.appendChild(opt);
  });
}
function loadBuild(){
  logDebug("Loading build");
  const name=document.getElementById("savedBuilds").value; if(!name)return;
  const data=savedBuilds[name];
  Object.keys(data).forEach(id=>{if(document.getElementById(id)) document.getElementById(id).value=data[id];});
  calculateFinalStats();
}
function deleteBuild(){
  logDebug("Deleting build");
  const name=document.getElementById("savedBuilds").value; if(!name)return;
  delete savedBuilds[name];
  localStorage.setItem("savedBuilds", JSON.stringify(savedBuilds));
  updateSavedDropdown();
}

// ---------------------------
// SHARE BUILD
// ---------------------------
document.getElementById("shareBuild").onclick = function() {
  logDebug("Sharing build");
  let buildData = {};
  ["W1","W2","W3","N1","N2","N3","A1","A2","A3","UW","U","Prime","Mega","corruptStat","corruptInput","geneticStat0","geneticStat1","geneticStat2","geneticValue0","geneticValue1","geneticValue2","targetHP","traitCleanseCounter","absoluteTraitCleanseCounter"].forEach(id => {
    buildData[id] = document.getElementById(id).value;
  });
  
  const encoded = btoa(JSON.stringify(buildData)); // Base64 encode for URL safety
  const shareUrl = `${window.location.origin}${window.location.pathname}?build=${encoded}`;
  
  // Copy to clipboard (fallback to prompt if copy fails)
  navigator.clipboard.writeText(shareUrl).then(() => {
    alert("Shareable URL copied to clipboard! Paste it to someone else.");
  }).catch(() => {
    prompt("Copy this shareable URL:", shareUrl);
  });
};

// ---------------------------
// LOAD SHARED BUILD FROM URL
// ---------------------------
function loadFromUrl() {
  logDebug("Loading from URL");
  const urlParams = new URLSearchParams(window.location.search);
  const buildParam = urlParams.get('build');
  if (buildParam) {
    try {
      const data = JSON.parse(atob(buildParam));
      Object.keys(data).forEach(id => {
        if (document.getElementById(id)) {
          document.getElementById(id).value = data[id];
        }
      });
      calculateFinalStats();
      alert("Build loaded from shared URL!");
    } catch (e) {
      logDebug("Error loading shared build: " + e.message);
      console.error("Invalid shared build data:", e);
    }
  }
}

// ---------------------------
// OPTIMIZE FUNCTIONS
// ---------------------------
const groups = [
  {cat: 'W', num_slots: 3, ids: ['W1', 'W2', 'W3']},
  {cat: 'N', num_slots: 3, ids: ['N1', 'N2', 'N3']},
  {cat: 'A', num_slots: 3, ids: ['A1', 'A2', 'A3']},
  {cat: 'UW', num_slots: 1, ids: ['UW']},
  {cat: 'U', num_slots: 1, ids: ['U']},
  {cat: 'P', num_slots: 1, ids: ['Prime']},
  {cat: 'M', num_slots: 1, ids: ['Mega']}
];

function getOptions(cat, maxCount, excluded) {
  logDebug(`Getting options for ${cat} with max ${maxCount}, excluded: ${excluded}`);
  const traits = traitData[cat].filter((t, i) => !excluded.includes(i));
  const len = traits.length;
  const opts = [];
  const generateCombo = (count, current = [], start = 0) => {
    if (current.length === count) {
      let d = 0, dr = 0, s = 0;
      const origCombo = current.map(filteredI => traitData[cat].findIndex(origT => origT.N === traits[filteredI].N)).sort((a, b) => a - b);
      current.forEach(filteredI => {
        const t = traits[filteredI];
        d += t.D || 0;
        dr += t.DR || 0;
        s += t.S || 0;
      });
      opts.push({ d, dr, s, combo: origCombo });
      return;
    }
    for (let i = start; i < len; i++) {
      generateCombo(count, [...current, i], i + 1);
    }
  };
  generateCombo(maxCount);
  logDebug(`Generated ${opts.length} options for ${cat}`);
  return opts;
}

function clearOptimizedTraits() {
  logDebug("Clearing optimized traits");
  groups.forEach(g => {
    if (g.cat !== 'P' && g.cat !== 'M') {
      g.ids.forEach(id => {
        document.getElementById(id).value = "";
      });
    }
  });
  calculateFinalStats();
}

function clearAll() {
  logDebug("Clearing all");
  groups.forEach(g => {
    g.ids.forEach(id => {
      document.getElementById(id).value = "";
    });
  });
  document.getElementById("corruptStat").value = "";
  document.getElementById("corruptInput").value = "";
  for (let i = 0; i < 3; i++) {
    document.getElementById("geneticStat" + i).value = "";
    document.getElementById("geneticValue" + i).value = "";
  }
  document.getElementById("targetHP").value = "";
  document.getElementById("minSpeed").value = "";
  document.getElementById("traitCleanseCounter").value = "";
  document.getElementById("absoluteTraitCleanseCounter").value = "";
  for (const cat in traitData) {
    const excludeSelect = document.getElementById(`exclude${cat}`);
    if (excludeSelect) {
      for (let opt of excludeSelect.options) {
        opt.selected = false;
      }
    }
  }
  calculateFinalStats();
}

function optimize(mode) {
  logDebug(`Starting optimization for mode: ${mode}`);
  document.getElementById('speed-context').innerHTML = '';
  const minDR = 75;
  const userMinS = parseFloat(document.getElementById('minSpeed').value) || 0;
  const wd = (mode === 'damage' || mode === 'all') ? 1 : 0;
  const ws = (mode === 'speed' || mode === 'all') ? 1 : 0;
  const useSConstraint = (mode === 'damage' && userMinS > 0);
  const tolerancePercent = 0.03;
  const tolerance = tolerancePercent * userMinS;
  const damageThreshold = 1.05;

  let fixedD = 0, fixedDR = 0, fixedS = 0;

  // Fixed from traits
  groups.forEach(g => {
    let groupFixedD = 0, groupFixedDR = 0, groupFixedS = 0;
    g.ids.forEach(id => {
      const val = document.getElementById(id).value;
      if (val && val.includes("-")) {
        const [, i] = val.split("-");
        const t = traitData[g.cat][parseInt(i)];
        groupFixedD += t.D || 0;
        groupFixedDR += t.DR || 0;
        groupFixedS += t.S || 0;
      }
    });
    fixedD += groupFixedD;
    fixedDR += groupFixedDR;
    fixedS += groupFixedS;
  });

  // Add fixed from corrupt
  const corruptStat = document.getElementById("corruptStat").value;
  const corruptValue = parseFloat(document.getElementById("corruptInput").value) || 0;
  if (corruptStat === "Damage") {
    fixedD += corruptValue;
  } else if (corruptStat === "DR") {
    fixedDR += corruptValue;
  } else if (corruptStat === "Speed") {
    fixedS += corruptValue;
  }

  // Add fixed from greaters
  for (let i = 0; i < 3; i++) {
    const stat = document.getElementById("geneticStat" + i).value;
    const val = parseFloat(document.getElementById("geneticValue" + i).value) || 0;
    if (stat === "Damage") {
      fixedD += val;
    } else if (stat === "DR") {
      fixedDR += val;
    } else if (stat === "Speed") {
      fixedS += val;
    }
  }
  logDebug(`Fixed values: D=${fixedD}, DR=${fixedDR}, S=${fixedS}`);

  // Unfixed groups
  let unfixedGroups = [];
  groups.forEach(g => {
    const excluded = Array.from(document.getElementById(`exclude${g.cat}`)?.selectedOptions || []).map(opt => parseInt(opt.value));
    let unfixedIds = [];
    g.ids.forEach((id, slotIndex) => {
      const val = document.getElementById(id).value;
      if (!val || !val.includes("-")) {
        unfixedIds.push({ id, slotIndex });
      }
    });
    const unfixedCount = unfixedIds.length;
    if (unfixedCount > 0) {
      unfixedGroups.push({ ...g, unfixedIds, unfixedCount, excluded });
    }
  });
  logDebug(`Unfixed groups: ${unfixedGroups.map(g => g.cat).join(", ")}`);

  if (unfixedGroups.length === 0) {
    logDebug("No unfixed groups, skipping optimization");
    calculateFinalStats();
    return;
  }

  let candidates = [];
  let recursionDepth = 0;

  function recurse(groupIndex = 0, accD = 0, accDR = 0, accS = 0, choices = {}) {
    recursionDepth++;
    if (recursionDepth > 10000) { // Safety limit
      logDebug("Recursion depth exceeded, possible infinite loop");
      return;
    }
    if (groupIndex === unfixedGroups.length) {
      const totalD = fixedD + accD;
      const totalDR = fixedDR + accDR;
      const totalS = fixedS + accS;
      const obj = wd * totalD + ws * totalS;
      candidates.push({ d: totalD, dr: totalDR, s: totalS, obj, choices: { ...choices } });
      return;
    }
    const g = unfixedGroups[groupIndex];
    const options = getOptions(g.cat, g.unfixedCount, g.excluded);
    if (options.length === 0) {
      recurse(groupIndex + 1, accD, accDR, accS, choices);
      return;
    }
    options.forEach(opt => {
      recurse(groupIndex + 1, accD + opt.d, accDR + opt.dr, accS + opt.s, { ...choices, [g.cat]: opt.combo });
    });
  }

  try {
    recurse();
    logDebug(`Generated ${candidates.length} candidates`);
  } catch (e) {
    logDebug("Error during recursion: " + e.message);
  }

  if (candidates.length > 0) {
    let dr_filtered = candidates.filter(c => c.dr >= minDR);
    let dr_fallback = dr_filtered.length === 0;
    let considered = dr_fallback ? candidates : dr_filtered;
    let dr_msg = dr_fallback ? ' (DR below 75%; could not reach with available traits)' : '';
    let msg = '';
    let best = null;

    const drSortDir = dr_fallback ? (a, b) => b.dr - a.dr : (a, b) => a.dr - b.dr;

    if (mode === 'damage' && useSConstraint) {
      let above = considered.filter(c => c.s >= userMinS);
      let maxD_above = above.length > 0 ? Math.max(...above.map(c => c.d)) : -Infinity;
      let below = considered.filter(c => c.s < userMinS && c.s >= userMinS - tolerance);
      let qualified_below = below.filter(c => c.d > maxD_above * damageThreshold);
      let s_considered = [...above, ...qualified_below];
      let s_fallback = s_considered.length === 0;
      if (s_fallback) {
        s_considered = considered;
      }
      s_considered.sort((a, b) => b.d - a.d || b.dr - a.dr || a.s - b.s);
      best = s_considered[0];
      let s_msg = '';
      if (!s_fallback && best) {
        const actualS = best.s;
        if (actualS >= userMinS) s_msg = ' (achieved or exceeded)';
        else if (actualS >= userMinS - tolerance) s_msg = ` (within 3% of desired: actual ${actualS.toFixed(1)}%)`;
      } else {
        s_msg = ' (below desired; no better options found)';
      }
      msg = s_msg + dr_msg;
    } else {
      let sortFunc;
      if (mode === 'damage') {
        sortFunc = (a, b) => b.d - a.d || b.dr - a.dr || a.s - b.s;
      } else if (mode === 'speed') {
        sortFunc = (a, b) => b.s - a.s || drSortDir(a, b);
      } else if (mode === 'all') {
        sortFunc = (a, b) => (b.d + b.s) - (a.d + a.s) || drSortDir(a, b);
      }
      considered.sort(sortFunc);
      best = considered[0];
      msg = dr_msg;
    }

    document.getElementById('speed-context').innerHTML = msg;
    logDebug(`Optimization message: ${msg}`);

    if (best && best.choices) {
      logDebug("Applying best choices");
      unfixedGroups.forEach(g => {
        let combo = best.choices[g.cat] || [];
        const sortedUnfixed = g.unfixedIds.sort((a, b) => a.slotIndex - b.slotIndex);
        for (let idx = 0; idx < sortedUnfixed.length; idx++) {
          const id = sortedUnfixed[idx].id;
          if (idx < combo.length) {
            document.getElementById(id).value = `${g.cat}-${combo[idx]}`;
          } else {
            document.getElementById(id).value = "";
          }
        }
      });
    } else {
      logDebug("No best candidate found");
    }
  } else {
    logDebug("No candidates generated");
  }
  calculateFinalStats();
  logDebug("Optimization completed");
}

function optimizeDamage() { optimize('damage'); }
function optimizeSpeed() { optimize('speed'); }
function optimizeAll() { optimize('all'); }

// Initialize
populateDropdowns();
updateSavedDropdown();
calculateFinalStats();
loadFromUrl();

// Event Listeners
document.getElementById("toggleTheme").onclick = function(){
  document.body.classList.toggle("dark-mode");
  this.textContent = document.body.classList.contains("dark-mode") ? "Switch to Light Mode" : "Switch to Dark Mode";
};
document.getElementById("saveBuild").onclick = saveBuild;
document.getElementById("loadBuild").onclick = loadBuild;
document.getElementById("deleteBuild").onclick = deleteBuild;
document.getElementById("optDamage").onclick = optimizeDamage;
document.getElementById("optSpeed").onclick = optimizeSpeed;
document.getElementById("optAll").onclick = optimizeAll;
document.getElementById("clearOptimized").onclick = clearOptimizedTraits;
document.getElementById("clearAll").onclick = clearAll;

// Auto-calculate on changes
const autoCalcElements = document.querySelectorAll('select:not(#savedBuilds):not([id^="exclude"]), input[type="number"]');
autoCalcElements.forEach(el => {
  el.addEventListener('change', calculateFinalStats);
  el.addEventListener('input', calculateFinalStats);
});

// Enforce min/max on specific inputs
function enforceRange(input, min, max) {
  input.addEventListener('input', function() {
    let val = parseFloat(this.value);
    if (isNaN(val)) {
      this.value = '';
    } else {
      if (val < min) this.value = min;
      if (val > max) this.value = max;
    }
  });
}

enforceRange(document.getElementById('corruptInput'), -25, 25);
enforceRange(document.getElementById('geneticValue0'), 5, 10);
enforceRange(document.getElementById('geneticValue1'), 5, 10);
enforceRange(document.getElementById('geneticValue2'), 5, 10);
enforceRange(document.getElementById('traitCleanseCounter'), 1, 5);
enforceRange(document.getElementById('absoluteTraitCleanseCounter'), 1, 3);

// Toggle view
document.getElementById('toggleView').addEventListener('click', () => {
  isMultiplierView = !isMultiplierView;
  calculateFinalStats();
});

// Pygmy Groups (similar to main)
const pygmyGroups = [
  {cat: 'W', maxSlots: 3, startingIds: ['pygmyStartingW1', 'pygmyStartingW2', 'pygmyStartingW3'], addablePrefix: 'pygmyAddW'},
  {cat: 'N', maxSlots: 3, startingIds: ['pygmyStartingN1', 'pygmyStartingN2', 'pygmyStartingN3'], addablePrefix: 'pygmyAddN'},
  {cat: 'A', maxSlots: 3, startingIds: [], addablePrefix: 'pygmyAddA'},
  {cat: 'UW', maxSlots: 1, startingIds: ['pygmyStartingUW'], addablePrefix: 'pygmyAddUW'},
  {cat: 'U', maxSlots: 1, startingIds: [], addablePrefix: 'pygmyAddU'},
  {cat: 'P', maxSlots: 1, startingIds: ['pygmyStartingPrime'], addablePrefix: 'pygmyAddPrime'},
  {cat: 'M', maxSlots: 1, startingIds: ['pygmyStartingMega'], addablePrefix: 'pygmyAddMega'}
];

// Populate Pygmy Dropdowns (call in populateDropdowns())
function populatePygmyDropdowns() {
  logDebug("Populating pygmy dropdowns");
  pygmyGroups.forEach(g => {
    g.startingIds.forEach(id => {
      const select = document.getElementById(id);
      if (select) {
        select.innerHTML = '<option value="">--None--</option>';
        traitData[g.cat].forEach((t, i) => {
          const opt = document.createElement('option');
          opt.value = i; // Just index, since no custom %s
          opt.text = t.N;
          select.appendChild(opt);
        });
      }
    });
  });

  // Populate exclude selects for Pygmy
  for (const cat in traitData) {
    const excludeSelect = document.getElementById(`pygmyExclude${cat}`);
    if (excludeSelect) {
      excludeSelect.innerHTML = "";
      traitData[cat].forEach((t, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = t.N;
        excludeSelect.appendChild(opt);
      });
    }
  }
}

// Call in main populateDropdowns()
populatePygmyDropdowns();

// Dynamic Addable Slots
function updatePygmyAddableSlots() {
  logDebug("Updating pygmy addable slots");
  const container = document.getElementById('pygmyAddableTraits');
  container.innerHTML = '';
  let hasPrime = document.getElementById('pygmyStartingPrime').value !== '';
  let hasMega = document.getElementById('pygmyStartingMega').value !== '';
  if (hasMega && !hasPrime) {
    alert("If a Pygmy has a Mega trait, it must also have a Prime trait. Please select a Prime trait.");
    document.getElementById('pygmyStartingMega').value = '';
    hasMega = false;
  }
  const leftColumn = document.createElement('div');
  leftColumn.className = 'addable-column';
  const rightColumn = document.createElement('div');
  rightColumn.className = 'addable-column';
  const columns = [leftColumn, rightColumn];
  let columnIndex = 0;
  pygmyGroups.forEach(g => {
    if ((g.cat === 'P' && hasPrime) || (g.cat === 'M' && hasMega)) return; // Lock if present
    const occupied = g.startingIds.filter(id => document.getElementById(id)?.value !== '').length;
    const available = g.maxSlots - occupied;
    if (available > 0) {
      const h4 = document.createElement('h4');
      h4.textContent = `Addable ${g.cat} – Up to ${available}`;
      columns[columnIndex % 2].appendChild(h4);
      for (let i = 1; i <= available; i++) {
        const select = document.createElement('select');
        select.id = `${g.addablePrefix}${i}`;
        select.innerHTML = '<option value="">--Select--</option>';
        traitData[g.cat].forEach((t, idx) => {
          const opt = document.createElement('option');
          opt.value = `${g.cat}-${idx}`;
          let parts = [];
          if (t.D !== 0) parts.push(`DMG ${t.D > 0 ? '+' : ''}${t.D}`);
          if (t.DR !== 0) parts.push(`DR ${t.DR > 0 ? '+' : ''}${t.DR}`);
          if (t.S !== 0) parts.push(`SPD ${t.S > 0 ? '+' : ''}${t.S}`);
          opt.text = `${t.N}${parts.length > 0 ? ` (${parts.join(', ')})` : ''}`;
          select.appendChild(opt);
        });
        columns[columnIndex % 2].appendChild(select);
      }
      columnIndex++;
    }
  });
  container.appendChild(leftColumn);
  container.appendChild(rightColumn);
  calculatePygmyFinalStats();
}

// Get Pygmy Totals
function getPygmyCurrentTotals() {
  logDebug("Getting pygmy current totals");
  let total = {
    Damage: parseFloat(document.getElementById('pygmyStartingDmg').value) || 0,
    DR: parseFloat(document.getElementById('pygmyStartingDR').value) || 0,
    Speed: parseFloat(document.getElementById('pygmyStartingSpd').value) || 0
  };

  // Add added traits (database values)
  pygmyGroups.forEach(g => {
    for (let i = 1; i <= g.maxSlots; i++) {
      const id = `${g.addablePrefix}${i}`;
      const val = document.getElementById(id)?.value;
      if (val && val.includes('-')) {
        const [cat, idx] = val.split('-');
        const t = traitData[cat][parseInt(idx)];
        total.Damage += t.D || 0;
        total.DR += t.DR || 0;
        total.Speed += t.S || 0;
      }
    }
  });

  return total;
}

// Calculate Pygmy Stats (similar to main)
let pygmyIsMultiplierView = true;
function calculatePygmyFinalStats() {
  logDebug("Calculating pygmy final stats");
  const total = getPygmyCurrentTotals();
  let drPercent = total.DR;
  let drWarning = '';
  if (drPercent > 75) { drWarning = ` <span class="warning">(${(drPercent - 75).toFixed(1)}% over cap)</span>`; drPercent = Math.min(drPercent, 75); }
  const dmg = 1 + total.Damage / 100, dr = 1 - drPercent / 100, spd = 1 + total.Speed / 100;
  let out;
  if (pygmyIsMultiplierView) {
    out = `Pygmy Bonus: Damage: ${dmg.toFixed(3)}, DR: ${dr.toFixed(3)}${drWarning}, SPD: ${spd.toFixed(3)}`;
  } else {
    out = `Pygmy Bonus: Damage: ${total.Damage.toFixed(1)}%, DR: ${drPercent.toFixed(1)}%${drWarning}, SPD: ${total.Speed.toFixed(1)}%`;
  }
  document.getElementById('pygmyFinalResult').innerHTML = out;
}

// Pygmy Optimize (adapted from main)
function pygmyOptimize(mode) {
  logDebug(`Starting pygmy optimization for mode: ${mode}`);
  document.getElementById('pygmySpeedContext').innerHTML = '';
  const minDR = 75;
  const userMinS = parseFloat(document.getElementById('pygmyMinSpeed').value) || 0;
  const wd = (mode === 'damage' || mode === 'all') ? 1 : 0;
  const ws = (mode === 'speed' || mode === 'all') ? 1 : 0;
  const useSConstraint = (mode === 'damage' && userMinS > 0);
  const tolerancePercent = 0.03;
  const tolerance = tolerancePercent * userMinS;
  const damageThreshold = 1.05;

  // Fixed from starting totals
  let fixedD = parseFloat(document.getElementById('pygmyStartingDmg').value) || 0;
  let fixedDR = parseFloat(document.getElementById('pygmyStartingDR').value) || 0;
  let fixedS = parseFloat(document.getElementById('pygmyStartingSpd').value) || 0;

  // Unfixed groups (addable slots only)
  let unfixedGroups = [];
  pygmyGroups.forEach(g => {
    const excluded = Array.from(document.getElementById(`pygmyExclude${g.cat}`)?.selectedOptions || []).map(opt => parseInt(opt.value));
    const occupied = g.startingIds.filter(id => document.getElementById(id)?.value !== '').length;
    const unfixedCount = g.maxSlots - occupied;
    let unfixedIds = [];
    for (let i = 1; i <= unfixedCount; i++) {
      unfixedIds.push({ id: `${g.addablePrefix}${i}`, slotIndex: i - 1 });
    }
    if (unfixedCount > 0) {
      unfixedGroups.push({ ...g, unfixedIds, unfixedCount, excluded });
    }
  });

  if (unfixedGroups.length === 0) {
    calculatePygmyFinalStats();
    return;
  }

  let candidates = [];

  function pygmyRecurse(groupIndex = 0, accD = 0, accDR = 0, accS = 0, choices = {}) {
    if (groupIndex === unfixedGroups.length) {
      const totalD = fixedD + accD;
      const totalDR = fixedDR + accDR;
      const totalS = fixedS + accS;
      const obj = wd * totalD + ws * totalS;
      candidates.push({ d: totalD, dr: totalDR, s: totalS, obj, choices: { ...choices } });
      return;
    }
    const g = unfixedGroups[groupIndex];
    const options = getOptions(g.cat, g.unfixedCount, g.excluded); // Reuse existing getOptions
    if (options.length === 0) {
      pygmyRecurse(groupIndex + 1, accD, accDR, accS, choices);
      return;
    }
    options.forEach(opt => {
      pygmyRecurse(groupIndex + 1, accD + opt.d, accDR + opt.dr, accS + opt.s, { ...choices, [g.cat]: opt.combo });
    });
  }

  pygmyRecurse();

  // Rest of sorting/best selection logic (copy from main optimize, with pygmy IDs)
  if (candidates.length > 0) {
    let dr_filtered = candidates.filter(c => c.dr >= minDR);
    let dr_fallback = dr_filtered.length === 0;
    let considered = dr_fallback ? candidates : dr_filtered;
    let dr_msg = dr_fallback ? ' (DR below 75%; could not reach with available traits)' : '';
    let msg = '';
    let best = null;

    const drSortDir = dr_fallback ? (a, b) => b.dr - a.dr : (a, b) => a.dr - b.dr;

    if (mode === 'damage' && useSConstraint) {
      let above = considered.filter(c => c.s >= userMinS);
      let maxD_above = above.length > 0 ? Math.max(...above.map(c => c.d)) : -Infinity;
      let below = considered.filter(c => c.s < userMinS && c.s >= userMinS - tolerance);
      let qualified_below = below.filter(c => c.d > maxD_above * damageThreshold);
      let s_considered = [...above, ...qualified_below];
      let s_fallback = s_considered.length === 0;
      if (s_fallback) s_considered = considered;
      s_considered.sort((a, b) => b.d - a.d || b.dr - a.dr || a.s - b.s);
      best = s_considered[0];
      let s_msg = '';
      if (!s_fallback && best) {
        const actualS = best.s;
        if (actualS >= userMinS) s_msg = ' (achieved or exceeded)';
        else if (actualS >= userMinS - tolerance) s_msg = ` (within 3% of desired: actual ${actualS.toFixed(1)}%)`;
      } else {
        s_msg = ' (below desired; no better options found)';
      }
      msg = s_msg + dr_msg;
    } else {
      let sortFunc;
      if (mode === 'damage') sortFunc = (a, b) => b.d - a.d || b.dr - a.dr || a.s - b.s;
      else if (mode === 'speed') sortFunc = (a, b) => b.s - a.s || drSortDir(a, b);
      else if (mode === 'all') sortFunc = (a, b) => (b.d + b.s) - (a.d + a.s) || drSortDir(a, b);
      considered.sort(sortFunc);
      best = considered[0];
      msg = dr_msg;
    }

    document.getElementById('pygmySpeedContext').innerHTML = msg;

    if (best && best.choices) {
      unfixedGroups.forEach(g => {
        let combo = best.choices[g.cat] || [];
        const sortedUnfixed = g.unfixedIds.sort((a, b) => a.slotIndex - b.slotIndex);
        for (let idx = 0; idx < sortedUnfixed.length; idx++) {
          const id = sortedUnfixed[idx].id;
          if (idx < combo.length) {
            document.getElementById(id).value = `${g.cat}-${combo[idx]}`;
          } else {
            document.getElementById(id).value = '';
          }
        }
      });
    }
  }
  calculatePygmyFinalStats();
}

// Event Listeners for Pygmy
const pygmyAutoCalcElements = document.querySelectorAll('#pygmyTraitPlanner select, #pygmyTraitPlanner input[type="number"]'); // Scoped if needed
pygmyAutoCalcElements.forEach(el => {
  el.addEventListener('change', () => { updatePygmyAddableSlots(); calculatePygmyFinalStats(); });
  el.addEventListener('input', () => { updatePygmyAddableSlots(); calculatePygmyFinalStats(); });
});

document.getElementById('pygmyOptDamage').onclick = () => pygmyOptimize('damage');
document.getElementById('pygmyOptSpeed').onclick = () => pygmyOptimize('speed');
document.getElementById('pygmyOptAll').onclick = () => pygmyOptimize('all');

document.getElementById('pygmyToggleView').addEventListener('click', () => {
  pygmyIsMultiplierView = !pygmyIsMultiplierView;
  calculatePygmyFinalStats();
});

// Initial call
updatePygmyAddableSlots();

// Debug Log Controls
document.getElementById("refreshLog").onclick = () => {
  document.getElementById("debugLog").value = debugLogs.join("\n");
};
document.getElementById("copyLog").onclick = () => {
  navigator.clipboard.writeText(debugLogs.join("\n")).then(() => {
    alert("Debug log copied to clipboard!");
  }).catch(() => {
    alert("Failed to copy log. Please copy from the textarea manually.");
  });
};
document.getElementById("clearLog").onclick = () => {
  debugLogs = [];
  document.getElementById("debugLog").value = "";
};
</script>
</body>
</html>
``` font-size